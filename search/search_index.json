{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Py-Swift Wiki","text":""},{"location":"setup/","title":"Setup","text":"<p>Add Brew Tap</p> <pre><code>brew tap PythonSwiftLink/tools\n</code></pre>"},{"location":"setup/#psproject","title":"PSProject","text":"<p>Install PSProject</p> <pre><code>brew install psproject\n</code></pre> <p>Upgrade PSProject</p> <pre><code>brew update\nbrew upgrade --formula psproject\n</code></pre>"},{"location":"project/kivy/create/","title":"kivy-project","text":"<p>First create uv project which psproject will use the pyproject.toml as project info</p> <pre><code>psproject init HelloWorld\n</code></pre> <p>cd into the new project - if terminal app only usage</p> <pre><code>cd HelloWorld\n</code></pre> <p>vscode users can instead open the folder by</p> <pre><code>code HelloWorld\n</code></pre> <p>You should now have a HelloWorld/pyproject.toml looking like this:</p> <pre><code>[project]\nname = \"helloworld\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nreadme = \"README.md\"\nauthors = [\n    { name = \"Py-Swift\", email = \"xyz@mail.com\" }\n]\nrequires-python = \"&gt;=3.13\"\ndependencies = []\n\n[project.scripts]\nhelloworld = \"helloworld:main\"\n\n[build-system]\nrequires = [\"uv_build&gt;=0.9.2,&lt;0.10.0\"]\nbuild-backend = \"uv_build\"\n\n[dependency-groups]\niphoneos = []\n\n[tool.psproject]\napp_name = \"HelloWorld\"\nbackends = []\ncythonized = false\nextra_index = []\npip_install_app = false\n\n[tool.psproject.ios]\nbackends = []\nextra_index = [\n    \"https://pypi.anaconda.org/beeware/simple\",\n    \"https://pypi.anaconda.org/pyswift/simple\",\n    \"https://pypi.anaconda.org/kivyschool/simple\"\n]\n\n[tool.psproject.ios.info_plist]\n\n[tool.psproject.ios.swift_packages]\n\n[tool.psproject.macos]\nbackends = []\nextra_index = []\n\n[tool.psproject.macos.info_plist]\n\n[tool.psproject.macos.swift_packages]\n\n[tool.psproject.swift_packages]\n</code></pre> <p>Now change the following properties to run a kivy based app:</p> <pre><code>[project]\nname = \"helloworld\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nreadme = \"README.md\"\nauthors = [\n    { name = \"Py-Swift\", email = \"xyz@mail.com\" }\n]\nrequires-python = \"&gt;=3.13\"\ndependencies = [\n    \"kivy&gt;=2.3.1\",\n]\n\n[project.scripts]\nhelloworld = \"helloworld:main\"\n\n[build-system]\nrequires = [\"uv_build&gt;=0.9.2,&lt;0.10.0\"]\nbuild-backend = \"uv_build\"\n\n[dependency-groups]\niphoneos = []\n\n[tool.psproject]\napp_name = \"HelloWorld\"\nbackends = [\n    \"kivyschool.kivylauncher\"\n]\ncythonized = false\nextra_index = []\npip_install_app = false\n\n[tool.psproject.ios]\nbackends = []\nextra_index = [\n    \"https://pypi.anaconda.org/beeware/simple\",\n    \"https://pypi.anaconda.org/pyswift/simple\",\n    \"https://pypi.anaconda.org/kivyschool/simple\"\n]\n\n[tool.psproject.ios.info_plist]\n\n[tool.psproject.ios.swift_packages]\n\n[tool.psproject.macos]\nbackends = []\nextra_index = []\n\n[tool.psproject.macos.info_plist]\n\n[tool.psproject.macos.swift_packages]\n\n[tool.psproject.swift_packages]\n</code></pre> <p>To create the xcode project, type the following command</p> <pre><code>psproject create xcode\n</code></pre> <p>To update the xcode project's site-packages, type the following command</p> <pre><code>psproject update site-packages\n</code></pre>"},{"location":"project/kivy/cythonized-project/","title":"Cythonized Project","text":"<p>This guide shows how to create a cythonized project where Python files are automatically converted to Cython (<code>.pyx</code>) and compiled to native code for better performance.</p>"},{"location":"project/kivy/cythonized-project/#what-is-a-cythonized-project","title":"What is a Cythonized Project?","text":"<p>A cythonized project automatically: - Converts all <code>.py</code> files to <code>.pyx</code> (Cython source files) - Compiles them to native C extensions - Generates local wheel packages for all target platforms - Serves them via a local simple package index</p> <p>This provides significant performance improvements while maintaining Python compatibility.</p>"},{"location":"project/kivy/cythonized-project/#creating-a-cythonized-project","title":"Creating a Cythonized Project","text":"<p>Initialize a new cythonized project</p> <pre><code>psproject init MyCythonApp --cythonized\n</code></pre> <p>This creates a new project with the <code>cythonized</code> key set to <code>true</code> in <code>pyproject.toml</code>.</p> <p>Navigate to the project directory</p> <pre><code>cd MyCythonApp\n</code></pre> <p>Or open in VS Code</p> <pre><code>code MyCythonApp\n</code></pre>"},{"location":"project/kivy/cythonized-project/#project-structure","title":"Project Structure","text":"<p>Your pyproject.toml will include the cythonized setting:</p> <pre><code>[tool.psproject]\ncythonized = true\nversion = \"0.1.0\"\n# ... other settings\n</code></pre> <p>When <code>cythonized = true</code>, the build system will:</p> <ol> <li>Convert all <code>.py</code> files to <code>.pyx</code> files</li> <li>Compile them using Cython for each target platform</li> <li>Package them as wheel files</li> <li>Index them in a local simple package repository</li> </ol>"},{"location":"project/kivy/cythonized-project/#build-workflow","title":"Build Workflow","text":""},{"location":"project/kivy/cythonized-project/#step-1-update-the-app-package","title":"Step 1: Update the App Package","text":"<p>After making changes to your Python code:</p> <p>Build and package the app as a wheel</p> <pre><code>psproject update app\n</code></pre> <p>This command: - Converts <code>.py</code> \u2192 <code>.pyx</code> files - Cythonizes the code for all platforms (iOS arm64, simulator x86_64/arm64, etc.) - Generates wheel files (.whl) for each platform - Places them in the local package repository</p>"},{"location":"project/kivy/cythonized-project/#step-2-update-the-simple-index","title":"Step 2: Update the Simple Index","text":"<p>Generate/update the local package index</p> <pre><code>psproject update simple\n</code></pre> <p>This command: - Scans all wheel files in the local repository - Generates a PEP 503 simple repository index - Makes packages available for pip installation</p>"},{"location":"project/kivy/cythonized-project/#step-3-create-xcode-project","title":"Step 3: Create Xcode Project","text":"<p>Generate the Xcode project</p> <pre><code>psproject create xcode\n</code></pre> <p>The Xcode project will be configured to automatically install the latest wheel during build.</p>"},{"location":"project/kivy/cythonized-project/#step-4-build-in-xcode","title":"Step 4: Build in Xcode","text":"<p>When you build in Xcode:</p> <ol> <li>Pre-build script runs <code>pip install</code> from the local simple index</li> <li>Latest wheel of your cythonized app is installed into site-packages</li> <li>Native compiled code runs on the device/simulator</li> </ol>"},{"location":"project/kivy/cythonized-project/#complete-example","title":"Complete Example","text":"<pre><code># Create a new cythonized project\npsproject init MyFastApp --cythonized\n\n# Navigate to the project\ncd MyFastApp\n</code></pre>"},{"location":"project/kivy/cythonized-project/#add-your-python-code","title":"Add your Python code","text":"<pre><code>def calculate_fibonacci(n: int) -&gt; int:\n    \"\"\"Calculate fibonacci number - will be cythonized for speed.\"\"\"\n    if n &lt;= 1:\n        return n\n    return calculate_fibonacci(n - 1) + calculate_fibonacci(n - 2)\n\ndef main():\n    result = calculate_fibonacci(30)\n    print(f\"Fibonacci(30) = {result}\")\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"project/kivy/cythonized-project/#build-the-cythonized-wheel","title":"Build the cythonized wheel","text":"<pre><code>psproject update app\n</code></pre>"},{"location":"project/kivy/cythonized-project/#update-the-package-index","title":"Update the package index","text":"<pre><code>psproject update simple\n</code></pre>"},{"location":"project/kivy/cythonized-project/#create-xcode-project","title":"Create Xcode project","text":"<pre><code>psproject create xcode\n</code></pre>"},{"location":"project/kivy/cythonized-project/#development-workflow","title":"Development Workflow","text":""},{"location":"project/kivy/cythonized-project/#making-code-changes","title":"Making Code Changes","text":"<p>When you modify your Python code:</p> <pre><code># 1. Edit your .py files\nvim my_module.py\n\n# 2. Rebuild the cythonized package\npsproject update app\n\n# 3. Update the index\npsproject update simple\n\n# 4. Rebuild in Xcode (or clean build)\n# The new wheel will be automatically installed\n</code></pre>"},{"location":"project/kivy/cythonized-project/#platform-specific-builds","title":"Platform-Specific Builds","text":"<p>The cythonization process creates wheels for:</p> <ul> <li>iOS Device (arm64)</li> <li>iOS Simulator (arm64 for M1+ Macs)</li> <li>iOS Simulator (x86_64 for Intel Macs)</li> </ul> <p>Each platform gets optimized native code.</p>"},{"location":"project/kivy/cythonized-project/#configuration-options","title":"Configuration Options","text":"<p>Example pyproject.toml for a cythonized Kivy app:</p> <pre><code>[project]\nname = \"MyFastApp\"\nversion = \"0.1.0\"\nrequires-python = \"&gt;=3.10\"\ndependencies = [\n    \"kivy&gt;=2.3.1\",\n]\n\n[build-system]\nrequires = [\"uv&gt;=0.9.2,&lt;0.10.0\"]\nbuild-backend = \"uv\"\n\n[tool.psproject]\nversion = \"0.1.0\"\ncythonized = true  # Enable Cython compilation\n\n[tool.psproject.app]\nmain_script = \"main.py\"\nrequirements = []\n\n[tool.psproject.ios]\nbundle_identifier = \"com.example.myfastapp\"\ndeployment_target = \"13.0\"\n\n[tool.psproject.swift_packages.PythonSwiftLink]\nexact = \"0.1.102\"\n</code></pre>"},{"location":"project/kivy/cythonized-project/#performance-benefits","title":"Performance Benefits","text":"<p>Cythonized code typically provides:</p> <ul> <li>2-10x faster execution for computational code</li> <li>Reduced memory overhead</li> <li>Native C performance for tight loops and calculations</li> <li>Type safety when using type hints</li> </ul> <p>Example performance comparison:</p> <pre><code># Pure Python (main.py)\ndef calculate_sum(n: int) -&gt; int:\n    total = 0\n    for i in range(n):\n        total += i\n    return total\n\n# After cythonization \u2192 native C code\n# Runs 5-10x faster on device!\n</code></pre>"},{"location":"project/kivy/cythonized-project/#automatic-build-integration","title":"Automatic Build Integration","text":"<p>The Xcode project includes a build phase that:</p> <pre><code># Pre-build script (automatically added)\npip install --index-url file:///path/to/simple MyFastApp\n</code></pre> <p>This ensures: - \u2705 Latest cythonized wheel is always installed - \u2705 No manual site-packages management needed - \u2705 Platform-specific optimized code is used</p>"},{"location":"project/kivy/cythonized-project/#troubleshooting","title":"Troubleshooting","text":""},{"location":"project/kivy/cythonized-project/#wheel-not-found","title":"Wheel Not Found","text":"<p>If <code>pip install</code> can't find your wheel:</p> <pre><code># Rebuild the wheel\npsproject update app\n\n# Regenerate the index\npsproject update simple\n\n# Verify the index exists\nls -la simple/\n</code></pre>"},{"location":"project/kivy/cythonized-project/#cython-compilation-errors","title":"Cython Compilation Errors","text":"<p>If you get Cython errors:</p> <pre><code># Check Python syntax is valid\npython -m py_compile main.py\n\n# Try disabling cythonized temporarily\n# Edit pyproject.toml: cythonized = false\n\n# Then re-enable after fixing issues\n</code></pre>"},{"location":"project/kivy/cythonized-project/#platform-mismatch","title":"Platform Mismatch","text":"<p>Make sure you're building for the right platform:</p> <pre><code># Check current platform wheels\nls *.whl\n\n# Should see files like:\n# MyApp-0.1.0-cp313-cp313-ios_13_0_iphoneos_arm64.whl\n# MyApp-0.1.0-cp313-cp313-ios_13_0_iphonesimulator_arm64.whl\n# MyApp-0.1.0-cp313-cp313-ios_13_0_iphonesimulator_x86_64.whl\n</code></pre>"},{"location":"project/kivy/cythonized-project/#advanced-type-hints-for-performance","title":"Advanced: Type Hints for Performance","text":"<p>Use Python type hints to get maximum Cython performance:</p> <pre><code># my_fast_module.py\ndef process_data(data: list[int]) -&gt; int:\n    \"\"\"Cython will optimize this with type information.\"\"\"\n    total: int = 0\n    value: int\n\n    for value in data:\n        total += value * 2\n\n    return total\n</code></pre> <p>After cythonization, this becomes highly optimized C code!</p>"},{"location":"project/kivy/cythonized-project/#pure-python-mode","title":"Pure Python Mode","text":"<p>Cython supports Pure Python Mode, which allows you to write Python code that remains valid Python but includes type annotations and hints that Cython uses for optimization. This is ideal for projects that need to run both as interpreted Python and as compiled extensions.</p>"},{"location":"project/kivy/cythonized-project/#three-approaches-to-pure-python-mode","title":"Three Approaches to Pure Python Mode","text":""},{"location":"project/kivy/cythonized-project/#1-using-the-cython-module-decorators-and-magic-attributes","title":"1. Using the <code>cython</code> Module (Decorators and Magic Attributes)","text":"<p>Import the <code>cython</code> module and use decorators to add type information:</p> <pre><code>import cython\n\n# Declare typed variables\n@cython.locals(x=cython.int, y=cython.int)\ndef add_numbers(x, y):\n    return x + y\n\n# Create a cdef class (extension type)\n@cython.cclass\nclass FastCalculator:\n    # Declare attributes\n    value: cython.int\n\n    def __init__(self, initial_value: int):\n        self.value = initial_value\n\n    @cython.cfunc  # C function (internal use)\n    @cython.returns(cython.int)\n    def _internal_calc(self, n: cython.int) -&gt; cython.int:\n        return self.value * n\n\n    @cython.ccall  # cpdef function (callable from Python and C)\n    def calculate(self, n: cython.int) -&gt; cython.int:\n        return self._internal_calc(n) + self.value\n\n# Check if code is compiled\nif cython.compiled:\n    print(\"Running as compiled extension!\")\nelse:\n    print(\"Running as interpreted Python\")\n</code></pre> <p>When run as Python, this code uses the fake <code>cython</code> module (from <code>Cython.Shadow</code>). When compiled, it becomes optimized C code.</p>"},{"location":"project/kivy/cythonized-project/#2-using-pep-484-type-annotations","title":"2. Using PEP-484 Type Annotations","text":"<p>Use standard Python type hints with <code>cython</code> types:</p> <pre><code>import cython\n\ndef process_array(data: list[int], multiplier: cython.int) -&gt; int:\n    \"\"\"Process array with Cython optimizations.\"\"\"\n    total: cython.int = 0\n    value: cython.int\n\n    for value in data:\n        total += value * multiplier\n\n    return total\n\n@cython.cclass\nclass Point:\n    x: cython.double\n    y: cython.double\n\n    def __init__(self, x: float, y: float):\n        self.x = x\n        self.y = y\n\n    def distance(self) -&gt; cython.double:\n        return cython.sqrt(self.x * self.x + self.y * self.y)\n</code></pre> <p>Type Annotation Benefits</p> <ul> <li>Works with static type checkers (mypy, pyright)</li> <li>Compatible with IDE autocomplete</li> <li>Provides Cython optimizations when compiled</li> <li>Remains valid Python when interpreted</li> </ul>"},{"location":"project/kivy/cythonized-project/#3-using-augmenting-pxd-files","title":"3. Using Augmenting <code>.pxd</code> Files","text":"<p>Keep your <code>.py</code> file as pure Python and create a matching <code>.pxd</code> file with type declarations:</p> <p>my_module.py (pure Python): <pre><code>def calculate_distance(x1, y1, x2, y2):\n    dx = x2 - x1\n    dy = y2 - y1\n    return (dx * dx + dy * dy) ** 0.5\n\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def move(self, dx, dy):\n        self.x += dx\n        self.y += dy\n</code></pre></p> <p>my_module.pxd (Cython type declarations): <pre><code>cpdef double calculate_distance(double x1, double y1, double x2, double y2)\n\ncdef class Point:\n    cdef public double x, y\n    cpdef move(self, double dx, double dy)\n</code></pre></p> <p>When Cython compiles <code>my_module.py</code>, it reads <code>my_module.pxd</code> and applies the type declarations automatically!</p>"},{"location":"project/kivy/cythonized-project/#practical-example-optimized-math-module","title":"Practical Example: Optimized Math Module","text":"<p>Here's a complete example combining all approaches:</p> <pre><code># fast_math.py\nimport cython\nfrom cython.cimports.libc import math\n\n@cython.cfunc\n@cython.returns(cython.double)\ndef _fast_sqrt(x: cython.double) -&gt; cython.double:\n    \"\"\"Internal C function for square root.\"\"\"\n    if cython.compiled:\n        return math.sqrt(x)\n    else:\n        import math as py_math\n        return py_math.sqrt(x)\n\n@cython.ccall\ndef euclidean_distance(\n    x1: cython.double,\n    y1: cython.double,\n    x2: cython.double,\n    y2: cython.double\n) -&gt; cython.double:\n    \"\"\"Calculate Euclidean distance - optimized when compiled.\"\"\"\n    dx: cython.double = x2 - x1\n    dy: cython.double = y2 - y1\n    return _fast_sqrt(dx * dx + dy * dy)\n\n@cython.cclass\nclass Vector2D:\n    \"\"\"2D vector with Cython optimizations.\"\"\"\n    x: cython.double\n    y: cython.double\n\n    def __init__(self, x: float, y: float):\n        self.x = x\n        self.y = y\n\n    @cython.ccall\n    def magnitude(self) -&gt; cython.double:\n        \"\"\"Calculate vector magnitude.\"\"\"\n        return _fast_sqrt(self.x * self.x + self.y * self.y)\n\n    @cython.ccall\n    def normalize(self) -&gt; None:\n        \"\"\"Normalize the vector in-place.\"\"\"\n        mag: cython.double = self.magnitude()\n        if mag &gt; 0:\n            self.x /= mag\n            self.y /= mag\n\n    def __repr__(self) -&gt; str:\n        return f\"Vector2D({self.x}, {self.y})\"\n\n# This works in both interpreted and compiled mode!\nif __name__ == \"__main__\":\n    v = Vector2D(3.0, 4.0)\n    print(f\"Vector: {v}\")\n    print(f\"Magnitude: {v.magnitude()}\")\n\n    v.normalize()\n    print(f\"Normalized: {v}\")\n\n    dist = euclidean_distance(0, 0, 3, 4)\n    print(f\"Distance: {dist}\")\n</code></pre>"},{"location":"project/kivy/cythonized-project/#available-cython-types","title":"Available Cython Types","text":"<p>When using pure Python mode, you can use these types:</p> <pre><code>import cython\n\n# Integer types\nx: cython.int          # C int\ny: cython.long         # C long\nz: cython.longlong     # C long long\n\n# Unsigned integers\nux: cython.uint        # unsigned int\nuy: cython.ulong       # unsigned long\n\n# Floating point\nf: cython.float        # C float\nd: cython.double       # C double\n\n# Boolean\nb: cython.bint         # C boolean (0/1)\n\n# Python types (for clarity)\npy_int: int            # Python int object\npy_list: list          # Python list object\npy_dict: dict          # Python dict object\n\n# Pointers (advanced)\nptr: cython.p_int      # int*\npptr: cython.pp_int    # int**\n</code></pre>"},{"location":"project/kivy/cythonized-project/#managing-the-gil-global-interpreter-lock","title":"Managing the GIL (Global Interpreter Lock)","text":"<p>For performance-critical sections, you can release the GIL:</p> <pre><code>import cython\n\n@cython.cfunc\n@cython.nogil  # This function can run without the GIL\ndef cpu_intensive_calculation(n: cython.int) -&gt; cython.long:\n    \"\"\"Pure C calculation, no Python objects.\"\"\"\n    result: cython.long = 0\n    i: cython.int\n\n    for i in range(n):\n        result += i * i\n\n    return result\n\ndef process_data(data: list[int]) -&gt; int:\n    \"\"\"Process data, releasing GIL for C operations.\"\"\"\n    result: cython.long\n\n    # Release GIL for the intensive calculation\n    with cython.nogil:\n        result = cpu_intensive_calculation(len(data))\n\n    # GIL automatically reacquired here\n    return int(result)\n</code></pre>"},{"location":"project/kivy/cythonized-project/#using-in-cythonized-projects","title":"Using in Cythonized Projects","text":"<p>When using <code>psproject init MyApp --cythonized</code>, you can write pure Python mode code that:</p> <ol> <li>Runs normally when testing in Python</li> <li>Gets optimized during the cythonization process</li> <li>Maintains compatibility with debugging tools</li> </ol> <p>Example workflow:</p> <pre><code># my_app/calculations.py\nimport cython\n\n@cython.cfunc\n@cython.returns(cython.double)\ndef _calculate_tax(amount: cython.double, rate: cython.double) -&gt; cython.double:\n    return amount * rate\n\n@cython.ccall\ndef process_transaction(amount: float, tax_rate: float) -&gt; dict:\n    \"\"\"Process a transaction with tax calculation.\"\"\"\n    tax: cython.double = _calculate_tax(amount, tax_rate)\n    total: cython.double = amount + tax\n\n    return {\n        'amount': amount,\n        'tax': tax,\n        'total': total,\n        'compiled': cython.compiled\n    }\n\n# When you run: psproject update app\n# This gets converted to .pyx and compiled to native code!\n</code></pre> <p>Pure Python Mode Advantages</p> <ul> <li>\u2705 Code runs without Cython installed (uses fallback)</li> <li>\u2705 Easier debugging with standard Python tools</li> <li>\u2705 Compatible with code coverage tools</li> <li>\u2705 Type hints help with IDE autocomplete</li> <li>\u2705 Gradual optimization (add types where needed)</li> <li>\u2705 Same codebase for development and production</li> </ul> <p>Limitations</p> <p>Some Cython features require <code>.pyx</code> syntax:</p> <ul> <li>C arrays: <code>cdef int arr[100]</code></li> <li>C structs and unions</li> <li>Complex pointer arithmetic</li> <li>Inline C code</li> </ul> <p>For these, you need to write <code>.pyx</code> files directly.</p> <p>Runtime Dependency</p> <p>Pure Python mode code imports <code>cython</code>. To avoid the runtime dependency, add this to your files:</p> <pre><code>try:\n    import cython\nexcept ImportError:\n    class _FakeCython:\n        compiled = False\n        def __getattr__(self, name):\n            return lambda *args, **kwargs: (lambda f: f) if callable(args[0] if args else None) else object\n    cython = _FakeCython()\n</code></pre>"},{"location":"project/kivy/cythonized-project/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Always update both app and simple index:    <pre><code>psproject update app &amp;&amp; psproject update simple\n</code></pre></p> </li> <li> <p>Clean builds after major changes:    <pre><code># In Xcode: Product \u2192 Clean Build Folder\n</code></pre></p> </li> <li> <p>Version your wheels using semantic versioning:    <pre><code>[project]\nversion = \"0.2.0\"  # Increment on changes\n</code></pre></p> </li> <li> <p>Test on device as Cython optimizations differ from simulator</p> </li> <li> <p>Use type hints for better performance optimization</p> </li> </ol> <p>Quick Reference</p> <pre><code># Create cythonized project\npsproject init MyApp --cythonized\n\n# Development cycle\npsproject update app      # Build cythonized wheels\npsproject update simple   # Update package index\n\n# Initial setup\npsproject create xcode    # Create Xcode project\n\n# Then just build in Xcode!\n</code></pre> <p>Platform Dependencies</p> <p>Some packages may not support all iOS platforms. If you encounter issues with a dependency:</p> <ul> <li>Check if it has pre-built wheels for iOS</li> <li>Consider using pure Python alternatives</li> <li>Report compatibility issues to the package maintainer</li> </ul> <p>Comparison: Standard vs Cythonized</p> <p>Standard Project: - <code>.py</code> files copied directly to site-packages - Interpreted at runtime - Easy to debug - Slower performance</p> <p>Cythonized Project: - <code>.py</code> \u2192 <code>.pyx</code> \u2192 compiled C extensions - Native machine code execution - Better performance (2-10x faster) - Requires rebuild on code changes</p>"},{"location":"project/kivy/pyproject-configuration/","title":"PyProject.toml Configuration Guide","text":"<p>This document explains all the configuration keys used in the <code>pyproject.toml</code> file for PySwift projects.</p>"},{"location":"project/kivy/pyproject-configuration/#standard-project-metadata","title":"Standard Project Metadata","text":"<p><code>[project]</code> - Standard Python project metadata following PEP 621</p> <ul> <li><code>name</code>: The name of your project/package</li> <li> <p>Example: <code>\"helloworld\"</code></p> </li> <li> <p><code>version</code>: The current version of your project following semantic versioning</p> </li> <li> <p>Example: <code>\"0.1.0\"</code></p> </li> <li> <p><code>description</code>: A brief description of what your project does</p> </li> <li> <p>Example: <code>\"Add your description here\"</code></p> </li> <li> <p><code>readme</code>: Path to the README file</p> </li> <li> <p>Example: <code>\"README.md\"</code></p> </li> <li> <p><code>authors</code>: List of project authors with name and email</p> </li> <li> <p>Example: <code>[{ name = \"Py-Swift\", email = \"psychowaspx@gmail.com\" }]</code></p> </li> <li> <p><code>requires-python</code>: Minimum Python version required</p> </li> <li> <p>Example: <code>\"&gt;=3.13\"</code></p> </li> <li> <p><code>dependencies</code>: List of Python package dependencies</p> </li> <li>Example: <code>[\"kivy&gt;=2.3.1\"]</code> or <code>[]</code> for no dependencies</li> </ul> <p><code>[project.scripts]</code> - Defines command-line entry points for your application</p> <ul> <li>Key: The command name that will be available in the terminal</li> <li>Value: The module and function to execute in format <code>\"module:function\"</code></li> <li>Example: <code>helloworld = \"helloworld:main\"</code> creates a <code>helloworld</code> command that runs the <code>main()</code> function from the <code>helloworld</code> module</li> </ul>"},{"location":"project/kivy/pyproject-configuration/#build-system","title":"Build System","text":"<p><code>[build-system]</code> - Specifies the build backend and its requirements</p> <ul> <li><code>requires</code>: List of packages needed to build the project</li> <li> <p>Example: <code>[\"uv_build&gt;=0.9.2,&lt;0.10.0\"]</code></p> </li> <li> <p><code>build-backend</code>: The build backend module to use</p> </li> <li>Example: <code>\"uv_build\"</code></li> </ul>"},{"location":"project/kivy/pyproject-configuration/#dependency-groups","title":"Dependency Groups","text":"<p><code>[dependency-groups]</code> - Optional dependency groups for different platforms or use cases</p> <ul> <li><code>iphoneos</code>: Dependencies specific to iPhone/iOS platform</li> <li>Example: <code>[]</code></li> </ul>"},{"location":"project/kivy/pyproject-configuration/#pyswift-project-configuration","title":"PySwift Project Configuration","text":"<p><code>[tool.psproject]</code> - Main PySwift project configuration section</p> <ul> <li><code>app_name</code>: The display name of your application</li> <li> <p>Example: <code>\"HelloWorld\"</code></p> </li> <li> <p><code>backends</code>: List of backend frameworks to use</p> </li> <li>Example: <code>[\"kivyschool.kivylauncher\"]</code></li> <li> <p>Common values: Kivy-based backends for cross-platform UI</p> </li> <li> <p><code>cythonized</code>: Whether to compile Python code with Cython for performance</p> </li> <li>Type: Boolean</li> <li> <p>Example: <code>false</code></p> </li> <li> <p><code>extra_index</code>: Additional PyPI index URLs for package resolution</p> </li> <li> <p>Example: <code>[]</code></p> </li> <li> <p><code>pip_install_app</code>: Whether to install the app using pip</p> </li> <li>Type: Boolean</li> <li>Example: <code>false</code></li> </ul> <p><code>[tool.psproject.ios]</code> - iOS-specific PySwift configuration</p> <ul> <li><code>backends</code>: iOS-specific backend frameworks</li> <li> <p>Example: <code>[]</code></p> </li> <li> <p><code>extra_index</code>: Additional package indexes for iOS dependencies</p> </li> <li>Example:     <pre><code>[\n    \"https://pypi.anaconda.org/beeware/simple\",\n    \"https://pypi.anaconda.org/pyswift/simple\",\n    \"https://pypi.anaconda.org/kivyschool/simple\"\n]\n</code></pre></li> <li>These indexes provide iOS-compatible wheels and packages</li> </ul> <p><code>[tool.psproject.ios.info_plist]</code> - iOS-specific Info.plist configuration</p> <p>This section can contain key-value pairs that will be added to the iOS app's Info.plist file.</p> <p>Common keys might include:</p> <ul> <li>Bundle identifiers</li> <li>App permissions (camera, microphone, etc.)</li> <li>Supported orientations</li> <li>App capabilities</li> </ul> <p><code>[tool.psproject.ios.swift_packages]</code> - iOS-specific Swift Package Manager dependencies</p> <p>Define Swift packages that your iOS app depends on.</p> <ul> <li>Format: Typically package name and version/URL specifications</li> </ul> <p><code>[tool.psproject.macos]</code> - macOS-specific PySwift configuration</p> <ul> <li><code>backends</code>: macOS-specific backend frameworks</li> <li> <p>Example: <code>[]</code></p> </li> <li> <p><code>extra_index</code>: Additional package indexes for macOS dependencies</p> </li> <li>Example: <code>[]</code></li> </ul> <p><code>[tool.psproject.macos.info_plist]</code> - macOS-specific Info.plist configuration</p> <p>Similar to iOS Info.plist but for macOS applications.</p> <p>Common keys might include:</p> <ul> <li>Bundle identifiers</li> <li>App permissions</li> <li>Supported file types</li> <li>App capabilities</li> </ul> <p><code>[tool.psproject.macos.swift_packages]</code> - macOS-specific Swift Package Manager dependencies</p> <p>Define Swift packages that your macOS app depends on.</p> <p><code>[tool.psproject.swift_packages]</code> - Cross-platform Swift Package Manager dependencies</p> <p>Define Swift packages that are used across iOS, macOS, and other supported platforms</p> <ul> <li>Format: Package specifications with URLs and version constraints</li> </ul>"},{"location":"project/kivy/pyproject-configuration/#example-usage","title":"Example Usage","text":"<p>Complete minimal configuration example (including all required sections)</p> <pre><code>[project]\nname = \"helloworld\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nreadme = \"README.md\"\nauthors = [\n    { name = \"Py-Swift\", email = \"psychowaspx@gmail.com\" }\n]\nrequires-python = \"&gt;=3.13\"\ndependencies = [\n    \"kivy&gt;=2.3.1\",\n]\n\n[project.scripts]\nhelloworld = \"helloworld:main\"\n\n[build-system]\nrequires = [\"uv_build&gt;=0.9.2,&lt;0.10.0\"]\nbuild-backend = \"uv_build\"\n\n[dependency-groups]\niphoneos = []\n\n[tool.psproject]\napp_name = \"HelloWorld\"\nbackends = [\n    \"kivyschool.kivylauncher\"\n]\ncythonized = false\nextra_index = []\npip_install_app = false\n\n[tool.psproject.ios]\nbackends = []\nextra_index = [\n    \"https://pypi.anaconda.org/beeware/simple\",\n    \"https://pypi.anaconda.org/pyswift/simple\",\n    \"https://pypi.anaconda.org/kivyschool/simple\"\n]\n\n[tool.psproject.ios.info_plist]\n\n[tool.psproject.ios.swift_packages]\n\n[tool.psproject.macos]\nbackends = []\nextra_index = []\n\n[tool.psproject.macos.info_plist]\n\n[tool.psproject.macos.swift_packages]\n\n[tool.psproject.swift_packages]\n</code></pre>"},{"location":"project/kivy/pyproject-configuration/#tips","title":"Tips","text":"<p>Version Constraints</p> <p>Always specify version constraints for dependencies to ensure reproducible builds</p> <p>Extra Indexes</p> <p>Order matters - indexes are checked in the order listed</p> <p>Platform Separation</p> <p>Keep platform-specific configuration in the appropriate sections</p> <p>Swift Packages</p> <p>Use Swift packages for native functionality that Python alone cannot provide</p>"},{"location":"wrapper_docs/other_types/","title":"Other Types and Advanced Conversions","text":"<p>This document covers additional type conversions and advanced usage patterns for PythonSwiftLink / Swiftonize.</p>"},{"location":"wrapper_docs/other_types/#numeric-types","title":"Numeric Types","text":"<p>Integer Types</p> <p>Python <code>int</code> automatically converts to various Swift integer types:</p> Python Type Swift Type Notes <code>int</code> <code>Int</code> Platform-native signed integer <code>int</code> <code>Int32</code> 32-bit signed integer <code>int</code> <code>Int16</code> 16-bit signed integer <code>int</code> <code>Int8</code> 8-bit signed integer <p>Unsigned Integer Types</p> <p>Python <code>int</code> also converts to Swift unsigned integer types:</p> Python Type Swift Type Notes <code>int</code> <code>UInt</code> Platform-native unsigned integer <code>int</code> <code>UInt32</code> 32-bit unsigned integer <code>int</code> <code>UInt16</code> 16-bit unsigned integer <code>int</code> <code>UInt8</code> 8-bit unsigned integer <p>Floating Point Types</p> <p>Python <code>float</code> converts to Swift floating-point types:</p> Python Type Swift Type Notes <code>float</code> <code>Double</code> 64-bit floating point (default) <code>float</code> <code>Float</code> 32-bit floating point <code>float</code> <code>Float16</code> 16-bit floating point"},{"location":"wrapper_docs/other_types/#string-and-data-types","title":"String and Data Types","text":"<p>String Types</p> Python Type Swift Type Description <code>str</code> <code>String</code> Unicode text strings <code>object</code> <code>PyPointer</code> Raw Python object pointer <p>Binary Data Types</p> <p>Python binary types convert to Swift data structures:</p> <p>bytes conversions:</p> Python Type Swift Type Description <code>bytes</code> <code>Data</code> Swift Data type <code>bytes</code> <code>[UInt8]</code> Array of bytes <p>bytearray conversions:</p> Python Type Swift Type Description <code>bytearray</code> <code>Data</code> Mutable byte sequence as Data <code>bytearray</code> <code>[UInt8]</code> Mutable byte sequence as array <p>memoryview conversions:</p> Python Type Swift Type Description <code>memoryview</code> <code>Data</code> Memory view as Data <code>memoryview</code> <code>[UInt8]</code> Memory view as byte array"},{"location":"wrapper_docs/other_types/#collection-types","title":"Collection Types","text":"<p>Integer Lists</p> <p>Python lists of integers convert to Swift arrays:</p> <p>Signed integer arrays:</p> Python Type Swift Type <code>list[int]</code> <code>[Int]</code> <code>list[int]</code> <code>[Int32]</code> <code>list[int]</code> <code>[Int16]</code> <code>list[int]</code> <code>[Int8]</code> <p>Unsigned integer arrays:</p> Python Type Swift Type <code>list[int]</code> <code>[UInt]</code> <code>list[int]</code> <code>[UInt32]</code> <code>list[int]</code> <code>[UInt16]</code> <code>list[int]</code> <code>[UInt8]</code> <p>Float Lists</p> <p>Python lists of floats convert to Swift floating-point arrays:</p> Python Type Swift Type <code>list[float]</code> <code>[Double]</code> <code>list[float]</code> <code>[Float]</code> <code>list[float]</code> <code>[Float16]</code> <p>Object and String Lists</p> Python Type Swift Type Description <code>list[object]</code> <code>[PyPointer]</code> Array of Python object pointers <code>list[str]</code> <code>[String]</code> Array of strings <p>Binary Data Lists</p> <p>Lists of bytes:</p> Python Type Swift Type <code>list[bytes]</code> <code>[Data]</code> <code>list[bytes]</code> <code>[[UInt8]]</code> <p>Lists of bytearray:</p> Python Type Swift Type <code>list[bytearray]</code> <code>[Data]</code> <code>list[bytearray]</code> <code>[[UInt8]]</code> <p>Lists of memoryview:</p> Python Type Swift Type <code>list[memoryview]</code> <code>[Data]</code> <code>list[memoryview]</code> <code>[[UInt8]]</code>"},{"location":"wrapper_docs/other_types/#type-conversion-notes","title":"Type Conversion Notes","text":"<p>Automatic Conversion</p> <p>All these conversions happen automatically when calling Swift functions from Python or vice versa. The bridge will handle the conversion based on the Swift function signature.</p> <p>Choosing the Right Type</p> <ul> <li>Use <code>Int</code>/<code>UInt</code> for general-purpose integers (platform-optimized)</li> <li>Use specific sized types (<code>Int32</code>, <code>UInt16</code>, etc.) when interfacing with APIs that require them</li> <li>Use <code>Double</code> for most floating-point operations (better precision)</li> <li>Use <code>Float</code> or <code>Float16</code> when memory/performance is critical</li> <li>Use <code>Data</code> for binary data when you need Foundation support</li> <li>Use <code>[UInt8]</code> for raw byte manipulation</li> </ul> <p>Usage Example</p> <pre><code># Python side\nmy_int = 42\nmy_floats = [3.14, 2.71, 1.41]\nmy_data = b\"Hello, Swift!\"\n\n# These will automatically convert when passed to Swift functions\nswift_object.process_int(my_int)  # Converts to Swift Int\nswift_object.process_floats(my_floats)  # Converts to [Double]\nswift_object.process_data(my_data)  # Converts to Data or [UInt8]\n</code></pre> <pre><code>// Swift side\nclass SwiftObject {\n    func processInt(_ value: Int) {\n        print(\"Received: \\(value)\")\n    }\n\n    func processFloats(_ values: [Double]) {\n        print(\"Float array: \\(values)\")\n    }\n\n    func processData(_ data: Data) {\n        print(\"Data size: \\(data.count)\")\n    }\n\n    // Swift to Python: Use .pyPointer()\n    func returnToPython() -&gt; PyPointer {\n        let swiftValue = 42\n        return swiftValue.pyPointer()\n    }\n\n    // Python to Swift: Use Type.casted(object:)\n    func receiveFromPython(_ obj: PyPointer) {\n        if let intValue = Int.casted(object: obj) {\n            print(\"Received int from Python: \\(intValue)\")\n        }\n        if let strValue = String.casted(object: obj) {\n            print(\"Received string from Python: \\(strValue)\")\n        }\n    }\n}\n</code></pre> <p>Performance Considerations</p> <ul> <li>Direct numeric conversions are very fast</li> <li>Collection conversions require copying data</li> <li>For large datasets, consider using <code>memoryview</code> or <code>Data</code> to minimize copying</li> <li><code>PyPointer</code> allows passing Python objects without conversion overhead</li> </ul>"},{"location":"wrapper_docs/types/","title":"Types","text":"<p>TypeCasting</p> <p>PythonSwiftLink / Swiftonize will automatic convert between the following python/swift types:</p> Python cast from/to Swift int Int int Int32 int Int16 int Int8 int UInt int UInt32 int UInt16 int UInt8 float Double float Float float Float16 object PyPointer str String bytes Data bytes [UInt8] bytearray Data bytearray [UInt8] memoryview Data memoryview [UInt8] list[int] [Int] list[int] [Int32] list[int] [Int16] list[int] [Int8] list[int] [UInt] list[int] [UInt32] list[int] [UInt16] list[int] [UInt8] list[float] [Double] list[float] [Float] list[float] [Float16] list[object] [PyPointer] list[str] [String] list[bytes] [Data] list[bytes] [[UInt8]] list[bytearray] [Data] list[bytearray] [[UInt8]] list[memoryview] [Data] list[memoryview] [[UInt8]]"},{"location":"wrapper_examples/audio_arpeggiator/","title":"AudioKit Arpeggiator","text":"<p>This example demonstrates wrapping an AudioKit-based arpeggiator that automatically plays held notes in ascending and descending patterns. It shows how to wrap audio engine components, MIDI instruments, sequencers, and real-time tempo/note length controls.</p>"},{"location":"wrapper_examples/audio_arpeggiator/#getting-started","title":"Getting Started","text":"<p>An arpeggiator takes a set of held notes and plays them sequentially in a pattern. This example uses:</p> <ul> <li>AppleSampler - AudioKit's sampler instrument for playback</li> <li>SequencerTrack - For timing and triggering arpeggio steps</li> <li>CallbackInstrument - For MIDI event handling</li> <li>AudioEngine - AudioKit's audio processing engine</li> </ul>"},{"location":"wrapper_examples/audio_arpeggiator/#part-1-basic-swift-implementation","title":"Part 1: Basic Swift Implementation","text":"<p>First, here's a basic Swift implementation without PySwiftKit:</p> <pre><code>import AudioKit\nimport AudioKitEX\nimport AVFoundation\n\nclass ArpeggiatorWrapper {\n    let engine = AudioEngine()\n    var instrument = AppleSampler()\n    var sequencer: SequencerTrack!\n    var midiCallback: CallbackInstrument!\n\n    var heldNotes = [Int]()\n    var isArpDescending = false\n    var currentNote = 0\n    var sequencerNoteLength = 1.0\n    var tempo: Float = 120.0\n\n    init() {\n        midiCallback = CallbackInstrument { status, note, vel in\n            if status == 144 { // Note On\n                self.fireTimer()\n            } else if status == 128 { // Note Off\n                // All notes off\n                for i in 0...127 {\n                    self.instrument.stop(noteNumber: UInt8(i), channel: 0)\n                }\n            }\n        }\n\n        engine.output = PeakLimiter(Mixer(instrument, midiCallback), \n                                    attackTime: 0.001, \n                                    decayTime: 0.001, \n                                    preGain: 0)\n\n        // Load instrument\n        if let fileURL = Bundle.main.url(forResource: \"sawPiano1\", withExtension: \"exs\") {\n            try? instrument.loadInstrument(url: fileURL)\n        }\n\n        sequencer = SequencerTrack(targetNode: midiCallback)\n        sequencer.length = 0.25\n        sequencer.loopEnabled = true\n        sequencer.add(noteNumber: 60, position: 0.0, duration: 0.24)\n        sequencer.tempo = 120.0\n        sequencer.playFromStart()\n    }\n\n    func addNote(_ pitch: Int) {\n        heldNotes.append(max(0, pitch))\n    }\n\n    func removeNote(_ pitch: Int) {\n        heldNotes = heldNotes.filter { $0 != pitch }\n    }\n\n    func fireTimer() {\n        // Stop all playing notes\n        for i in 0...127 {\n            instrument.stop(noteNumber: UInt8(i), channel: 0)\n        }\n\n        if heldNotes.count &lt; 1 {\n            return\n        }\n\n        // Arpeggiator algorithm\n        if !isArpDescending {\n            if heldNotes.max() != currentNote {\n                currentNote = heldNotes.filter { $0 &gt; currentNote }.min() ?? heldNotes.min()!\n            } else {\n                isArpDescending = true\n                currentNote = heldNotes.filter { $0 &lt; currentNote }.max() ?? heldNotes.max()!\n            }\n        } else {\n            if heldNotes.min() != currentNote {\n                currentNote = heldNotes.filter { $0 &lt; currentNote }.max() ?? heldNotes.max()!\n            } else {\n                isArpDescending = false\n                currentNote = heldNotes.filter { $0 &gt; currentNote }.min() ?? heldNotes.min()!\n            }\n        }\n\n        instrument.play(noteNumber: UInt8(currentNote), velocity: 120, channel: 0)\n    }\n\n    func setTempo(_ bpm: Float) {\n        tempo = bpm\n        sequencer.tempo = Double(bpm)\n    }\n\n    func setNoteLength(_ length: Float) {\n        sequencerNoteLength = Double(length)\n        sequencer.clear()\n        sequencer.add(noteNumber: 60, position: 0.0, duration: max(0.05, sequencerNoteLength * 0.24))\n    }\n\n    func start() {\n        try? engine.start()\n        sequencer.playFromStart()\n    }\n\n    func stop() {\n        engine.stop()\n        sequencer.stop()\n    }\n}\n</code></pre> <p>This implementation handles note input, arpeggio pattern generation, tempo control, and MIDI timing.</p>"},{"location":"wrapper_examples/audio_arpeggiator/#part-2-swift-with-pyswiftkit","title":"Part 2: Swift with PySwiftKit","text":"<p>Now let's wrap it with PySwiftKit decorators to expose it to Python:</p> <pre><code>import AudioKit\nimport AudioKitEX\nimport AVFoundation\nimport PythonSwiftLink\n\n@PyClass\nclass AudioArpeggiator {\n    let engine = AudioEngine()\n    var instrument = AppleSampler()\n    var sequencer: SequencerTrack!\n    var midiCallback: CallbackInstrument!\n\n    var heldNotes = [Int]()\n    var isArpDescending = false\n    var currentNote = 0\n    var sequencerNoteLength = 1.0\n    var tempo: Float = 120.0\n\n    @PyInit\n    init() {\n        midiCallback = CallbackInstrument { [weak self] status, note, vel in\n            guard let self = self else { return }\n            if status == 144 { // Note On\n                self.fireTimer()\n            } else if status == 128 { // Note Off\n                // All notes off\n                for i in 0...127 {\n                    self.instrument.stop(noteNumber: UInt8(i), channel: 0)\n                }\n            }\n        }\n\n        engine.output = PeakLimiter(Mixer(instrument, midiCallback), \n                                    attackTime: 0.001, \n                                    decayTime: 0.001, \n                                    preGain: 0)\n\n        // Load instrument from bundle\n        if let fileURL = Bundle.main.url(forResource: \"sawPiano1\", withExtension: \"exs\") {\n            try? instrument.loadInstrument(url: fileURL)\n        }\n\n        sequencer = SequencerTrack(targetNode: midiCallback)\n        sequencer.length = 0.25\n        sequencer.loopEnabled = true\n        sequencer.add(noteNumber: 60, position: 0.0, duration: 0.24)\n        sequencer.tempo = 120.0\n        sequencer.playFromStart()\n    }\n\n    @PyMethod\n    func add_note(_ pitch: Int) {\n        heldNotes.append(max(0, pitch))\n    }\n\n    @PyMethod\n    func remove_note(_ pitch: Int) {\n        heldNotes = heldNotes.filter { $0 != pitch }\n    }\n\n    @PyMethod\n    func clear_notes() {\n        heldNotes.removeAll()\n    }\n\n    @PyMethod\n    func get_held_notes() -&gt; [Int] {\n        return heldNotes\n    }\n\n    func fireTimer() {\n        // Stop all playing notes\n        for i in 0...127 {\n            instrument.stop(noteNumber: UInt8(i), channel: 0)\n        }\n\n        if heldNotes.count &lt; 1 {\n            return\n        }\n\n        // Arpeggiator algorithm - ascending then descending\n        if !isArpDescending {\n            if heldNotes.max() != currentNote {\n                currentNote = heldNotes.filter { $0 &gt; currentNote }.min() ?? heldNotes.min()!\n            } else {\n                isArpDescending = true\n                currentNote = heldNotes.filter { $0 &lt; currentNote }.max() ?? heldNotes.max()!\n            }\n        } else {\n            if heldNotes.min() != currentNote {\n                currentNote = heldNotes.filter { $0 &lt; currentNote }.max() ?? heldNotes.max()!\n            } else {\n                isArpDescending = false\n                currentNote = heldNotes.filter { $0 &gt; currentNote }.min() ?? heldNotes.min()!\n            }\n        }\n\n        instrument.play(noteNumber: UInt8(currentNote), velocity: 120, channel: 0)\n    }\n\n    @PyMethod\n    func set_tempo(_ bpm: Float) {\n        tempo = max(20.0, min(250.0, bpm))  // Clamp to reasonable range\n        sequencer.tempo = Double(tempo)\n    }\n\n    @PyMethod\n    func get_tempo() -&gt; Float {\n        return tempo\n    }\n\n    @PyMethod\n    func set_note_length(_ length: Float) {\n        sequencerNoteLength = Double(max(0.0, min(1.0, length)))  // Clamp 0-1\n        sequencer.clear()\n        sequencer.add(noteNumber: 60, position: 0.0, duration: max(0.05, sequencerNoteLength * 0.24))\n    }\n\n    @PyMethod\n    func get_note_length() -&gt; Float {\n        return Float(sequencerNoteLength)\n    }\n\n    @PyMethod\n    func start() {\n        do {\n            try engine.start()\n            sequencer.playFromStart()\n        } catch {\n            print(\"Failed to start audio engine: \\(error)\")\n        }\n    }\n\n    @PyMethod\n    func stop() {\n        engine.stop()\n        sequencer.stop()\n    }\n\n    @PyMethod\n    func pause() {\n        sequencer.stop()\n    }\n\n    @PyMethod\n    func resume() {\n        sequencer.playFromStart()\n    }\n}\n\n@PyModule\nclass ArpeggiatorModule {\n    static func registerTypes() {\n        AudioArpeggiator.register()\n    }\n}\n</code></pre> <p>Key AudioKit Components</p> <ul> <li>AppleSampler: Loads and plays sampled instruments (.exs, .sf2, .wav files)</li> <li>SequencerTrack: Provides timing for arpeggio steps with tempo control</li> <li>CallbackInstrument: Receives MIDI events for triggering notes</li> <li>AudioEngine: Manages the audio processing graph</li> <li>PeakLimiter/Mixer: Audio processing nodes for output management</li> </ul>"},{"location":"wrapper_examples/audio_arpeggiator/#part-3-python-interface","title":"Part 3: Python Interface","text":"<p>Define the Python interface to interact with the arpeggiator:</p> <pre><code>from typing import List\n\nclass AudioArpeggiator:\n    \"\"\"AudioKit-based arpeggiator with tempo and note length controls.\"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize the arpeggiator with default settings (120 BPM, note length 1.0).\"\"\"\n        ...\n\n    def add_note(self, pitch: int) -&gt; None:\n        \"\"\"\n        Add a note to the arpeggiator.\n\n        Args:\n            pitch: MIDI note number (0-127)\n        \"\"\"\n        ...\n\n    def remove_note(self, pitch: int) -&gt; None:\n        \"\"\"\n        Remove a note from the arpeggiator.\n\n        Args:\n            pitch: MIDI note number to remove\n        \"\"\"\n        ...\n\n    def clear_notes(self) -&gt; None:\n        \"\"\"Clear all held notes.\"\"\"\n        ...\n\n    def get_held_notes(self) -&gt; List[int]:\n        \"\"\"\n        Get the list of currently held notes.\n\n        Returns:\n            List of MIDI note numbers\n        \"\"\"\n        ...\n\n    def set_tempo(self, bpm: float) -&gt; None:\n        \"\"\"\n        Set the arpeggiator tempo.\n\n        Args:\n            bpm: Beats per minute (20-250)\n        \"\"\"\n        ...\n\n    def get_tempo(self) -&gt; float:\n        \"\"\"\n        Get the current tempo.\n\n        Returns:\n            Current BPM\n        \"\"\"\n        ...\n\n    def set_note_length(self, length: float) -&gt; None:\n        \"\"\"\n        Set the note length parameter.\n\n        Args:\n            length: Note length (0.0-1.0, where 1.0 is full note duration)\n        \"\"\"\n        ...\n\n    def get_note_length(self) -&gt; float:\n        \"\"\"\n        Get the current note length.\n\n        Returns:\n            Current note length (0.0-1.0)\n        \"\"\"\n        ...\n\n    def start(self) -&gt; None:\n        \"\"\"Start the audio engine and sequencer.\"\"\"\n        ...\n\n    def stop(self) -&gt; None:\n        \"\"\"Stop the audio engine and sequencer.\"\"\"\n        ...\n\n    def pause(self) -&gt; None:\n        \"\"\"Pause the sequencer (keeps audio engine running).\"\"\"\n        ...\n\n    def resume(self) -&gt; None:\n        \"\"\"Resume the sequencer.\"\"\"\n        ...\n</code></pre>"},{"location":"wrapper_examples/audio_arpeggiator/#usage-example","title":"Usage Example","text":"<pre><code>from audio_arpeggiator import AudioArpeggiator\nimport time\n\n# Create and start arpeggiator\narp = AudioArpeggiator()\narp.start()\n\n# Play a C major chord arpeggiated\narp.add_note(60)  # C\narp.add_note(64)  # E\narp.add_note(67)  # G\n\n# Let it play for a bit\ntime.sleep(4)\n\n# Change tempo\narp.set_tempo(180.0)  # Speed up to 180 BPM\ntime.sleep(2)\n\n# Adjust note length (shorter, more staccato)\narp.set_note_length(0.3)\ntime.sleep(2)\n\n# Add more notes (C major 7th)\narp.add_note(71)  # B\ntime.sleep(2)\n\n# Remove a note\narp.remove_note(64)  # Remove E\ntime.sleep(2)\n\n# Check what's playing\nprint(f\"Held notes: {arp.get_held_notes()}\")\nprint(f\"Current tempo: {arp.get_tempo()} BPM\")\nprint(f\"Note length: {arp.get_note_length()}\")\n\n# Clear and play new pattern\narp.clear_notes()\narp.add_note(57)  # A\narp.add_note(60)  # C\narp.add_note(64)  # E\narp.add_note(69)  # A (octave)\n\ntime.sleep(4)\n\n# Pause and resume\narp.pause()\ntime.sleep(1)\narp.resume()\ntime.sleep(2)\n\n# Clean up\narp.stop()\n</code></pre>"},{"location":"wrapper_examples/audio_arpeggiator/#advanced-usage-interactive-music-app","title":"Advanced Usage: Interactive Music App","text":"<pre><code>from audio_arpeggiator import AudioArpeggiator\nimport time\n\nclass ArpeggioMusicBox:\n    \"\"\"Interactive music box with multiple arpeggiator patterns.\"\"\"\n\n    def __init__(self):\n        self.arp = AudioArpeggiator()\n        self.arp.start()\n        self.patterns = {\n            'c_major': [60, 64, 67, 72],\n            'a_minor': [57, 60, 64, 69],\n            'f_major': [53, 57, 60, 65],\n            'g_major': [55, 59, 62, 67],\n        }\n\n    def play_pattern(self, name: str, duration: float = 4.0):\n        \"\"\"Play a chord pattern.\"\"\"\n        if name not in self.patterns:\n            print(f\"Unknown pattern: {name}\")\n            return\n\n        # Clear previous notes\n        self.arp.clear_notes()\n\n        # Add new pattern\n        for note in self.patterns[name]:\n            self.arp.add_note(note)\n\n        print(f\"Playing {name}: {self.arp.get_held_notes()}\")\n        time.sleep(duration)\n\n    def play_progression(self, tempo: float = 120.0):\n        \"\"\"Play a chord progression.\"\"\"\n        self.arp.set_tempo(tempo)\n        self.arp.set_note_length(0.8)\n\n        progression = ['c_major', 'a_minor', 'f_major', 'g_major']\n\n        for chord in progression:\n            self.play_pattern(chord, duration=4.0)\n\n    def improvise(self, duration: float = 10.0):\n        \"\"\"Create improvised patterns with tempo changes.\"\"\"\n        import random\n\n        start_time = time.time()\n\n        while time.time() - start_time &lt; duration:\n            # Random tempo change\n            tempo = random.uniform(80, 180)\n            self.arp.set_tempo(tempo)\n\n            # Random note length\n            note_length = random.uniform(0.2, 1.0)\n            self.arp.set_note_length(note_length)\n\n            # Random pattern\n            pattern = random.choice(list(self.patterns.keys()))\n            self.play_pattern(pattern, duration=2.0)\n\n    def stop(self):\n        \"\"\"Stop the arpeggiator.\"\"\"\n        self.arp.stop()\n\n# Example usage\nmusic_box = ArpeggioMusicBox()\n\nprint(\"Playing chord progression...\")\nmusic_box.play_progression(tempo=140)\n\nprint(\"\\nImprovising...\")\nmusic_box.improvise(duration=10)\n\nprint(\"\\nCleaning up...\")\nmusic_box.stop()\n</code></pre> <p>MIDI Note Numbers</p> <ul> <li>C4 (Middle C): 60</li> <li>Each octave: +/- 12 semitones</li> <li>Range: 0-127 (MIDI standard)</li> <li>Common chords:<ul> <li>C Major: [60, 64, 67]</li> <li>A minor: [57, 60, 64]</li> <li>G Major: [55, 59, 62]</li> </ul> </li> </ul> <p>Audio Resources</p> <p>The AppleSampler requires an instrument file to be loaded. Make sure to:</p> <ul> <li>Include <code>.exs</code> (Logic/GarageBand instrument) or <code>.sf2</code> (SoundFont) files in your app bundle</li> <li>Update the file path in <code>loadInstrument(url:)</code> to match your resources</li> <li>Handle errors when loading fails</li> </ul> <pre><code>if let fileURL = Bundle.main.url(forResource: \"yourInstrument\", withExtension: \"exs\") {\n    try instrument.loadInstrument(url: fileURL)\n}\n</code></pre> <p>Arpeggiator Algorithm</p> <p>The arpeggiator uses an ascending-descending pattern:</p> <ol> <li>Plays notes in ascending order until reaching the highest note</li> <li>Switches to descending order</li> <li>Plays down to the lowest note</li> <li>Switches back to ascending</li> <li>Repeats continuously</li> </ol> <p>This creates a smooth, musical pattern that's common in synthesizers and sequencers.</p> <p>Performance Considerations</p> <ul> <li>The SequencerTrack runs on a separate thread for accurate timing</li> <li>CallbackInstrument events are triggered at each sequencer step</li> <li>AudioEngine should be started before adding notes for immediate playback</li> <li>Use <code>pause()</code>/<code>resume()</code> instead of <code>stop()</code>/<code>start()</code> to avoid audio glitches</li> </ul>"},{"location":"wrapper_examples/audio_arpeggiator/#use-cases","title":"Use Cases","text":"<p>Music Production Tools <pre><code># Create a music sketching app\nfrom audio_arpeggiator import AudioArpeggiator\n\nclass MusicSketchpad:\n    def __init__(self):\n        self.arp = AudioArpeggiator()\n        self.arp.set_tempo(120)\n        self.arp.start()\n\n    def sketch_idea(self, notes, tempo=120, length=0.8):\n        \"\"\"Quickly sketch a musical idea.\"\"\"\n        self.arp.set_tempo(tempo)\n        self.arp.set_note_length(length)\n        self.arp.clear_notes()\n        for note in notes:\n            self.arp.add_note(note)\n</code></pre></p> <p>Educational Apps <pre><code># Teach music theory with interactive arpeggios\nclass MusicTheoryTeacher:\n    def __init__(self):\n        self.arp = AudioArpeggiator()\n        self.arp.start()\n\n    def demonstrate_chord(self, root, chord_type):\n        \"\"\"Demonstrate a chord by arpeggiation.\"\"\"\n        intervals = {\n            'major': [0, 4, 7],\n            'minor': [0, 3, 7],\n            'dim': [0, 3, 6],\n            'aug': [0, 4, 8],\n        }\n\n        self.arp.clear_notes()\n        for interval in intervals[chord_type]:\n            self.arp.add_note(root + interval)\n</code></pre></p> <p>Generative Music <pre><code># Create evolving ambient soundscapes\nimport random\nimport time\n\nclass AmbientGenerator:\n    def __init__(self):\n        self.arp = AudioArpeggiator()\n        self.arp.set_tempo(60)  # Slow, ambient tempo\n        self.arp.set_note_length(0.9)  # Long, flowing notes\n        self.arp.start()\n\n    def evolve(self, duration=30):\n        \"\"\"Generate evolving ambient patterns.\"\"\"\n        scale = [60, 62, 64, 67, 69, 72]  # Pentatonic scale\n\n        start = time.time()\n        while time.time() - start &lt; duration:\n            # Randomly add or remove notes\n            if random.random() &gt; 0.5 and len(self.arp.get_held_notes()) &lt; 5:\n                note = random.choice(scale)\n                self.arp.add_note(note)\n            elif self.arp.get_held_notes():\n                note = random.choice(self.arp.get_held_notes())\n                self.arp.remove_note(note)\n\n            time.sleep(random.uniform(2, 5))\n</code></pre></p>"},{"location":"wrapper_examples/battery_level/","title":"Battery level","text":""},{"location":"wrapper_examples/battery_level/#getting-started","title":"Getting started","text":"<p>This tutorial demonstrates how to monitor iOS battery level and state changes from Python using PythonSwiftLink. You'll learn how to enable battery monitoring, read the current battery level, and receive notifications when the battery state changes. This is useful for apps that need to display battery indicators, detect power outages, or respond to low power conditions.</p>"},{"location":"wrapper_examples/battery_level/#batterymonitor-part-1","title":"BatteryMonitor Part 1","text":"<p>Call Swift from Python to read battery level:</p> <p>Let's start with a basic Swift class that monitors the device's battery. iOS provides battery information through <code>UIDevice</code>, but we need to enable monitoring first.</p> BatteryMonitor.swift<pre><code>import UIKit\n\npublic class BatteryMonitor {\n\n    init() {\n        UIDevice.current.isBatteryMonitoringEnabled = true\n    }\n\n    func get_battery_level() -&gt; Float {\n        return UIDevice.current.batteryLevel\n    }\n\n    func get_battery_state() -&gt; String {\n        switch UIDevice.current.batteryState {\n        case .unknown:\n            return \"unknown\"\n        case .unplugged:\n            return \"unplugged\"\n        case .charging:\n            return \"charging\"\n        case .full:\n            return \"full\"\n        @unknown default:\n            return \"unknown\"\n        }\n    }\n}\n</code></pre> <p>To make this Swift class accessible from Python, we need to add PySwiftKit decorators. The <code>@PyClass</code> decorator marks the class as exportable to Python, <code>@PyInit</code> wraps the initializer, and <code>@PyMethod</code> exposes methods to Python. We also need to define a module structure using <code>@PyModule</code>.</p> <p>Here's the same class with the necessary wrappers:</p> BatteryMonitor.swift<pre><code>import UIKit\nimport PySwiftKit\nimport PySerializing\nimport PySwiftObject\nimport PySwiftWrapper\n\n\n@PyClass\nclass BatteryMonitor {\n\n    @PyInit\n    init() {\n        UIDevice.current.isBatteryMonitoringEnabled = true\n    }\n\n    @PyMethod\n    func get_battery_level() -&gt; Float {\n        return UIDevice.current.batteryLevel\n    }\n\n    @PyMethod\n    func get_battery_state() -&gt; String {\n        switch UIDevice.current.batteryState {\n        case .unknown:\n            return \"unknown\"\n        case .unplugged:\n            return \"unplugged\"\n        case .charging:\n            return \"charging\"\n        case .full:\n            return \"full\"\n        @unknown default:\n            return \"unknown\"\n        }\n    }\n}\n\n@PyModule\nstruct battery_monitor: PyModuleProtocol {\n    static var py_classes: [any (PyClassProtocol &amp; AnyObject).Type] = [\n        BatteryMonitor.self\n    ]\n}\n</code></pre> <p>The <code>@PyModule</code> struct defines a Python module named <code>battery_monitor</code> that contains our BatteryMonitor class. The <code>py_classes</code> array lists all classes that should be available in the module.</p> <p>Once compiled, this creates a Python module that can be imported and used like any native Python class:</p> battery_monitor.py<pre><code>class BatteryMonitor:\n\n    def __init__(self): ...\n\n    def get_battery_level(self) -&gt; float: ...\n\n    def get_battery_state(self) -&gt; str: ...\n</code></pre> main.py<pre><code>from battery_monitor import BatteryMonitor\n\nmonitor = BatteryMonitor()\n\n# Get battery level (0.0 to 1.0)\nlevel = monitor.get_battery_level()\nprint(f\"Battery level: {level * 100}%\")\n\n# Get battery state\nstate = monitor.get_battery_state()\nprint(f\"Battery state: {state}\")\n</code></pre>"},{"location":"wrapper_examples/battery_level/#batterymonitor-part-2","title":"BatteryMonitor Part 2","text":"<p>Now let's implement battery level change notifications. iOS sends the <code>UIDeviceBatteryLevelDidChange</code> notification (up to once per minute) when the battery level changes. We'll register for this notification and call back to Python when changes occur.</p> <p>Make callback from Swift to Python on battery changes:</p> BatteryMonitor.swift<pre><code>import UIKit\nimport PySwiftKit\nimport PySerializing\nimport PySwiftObject\nimport PySwiftWrapper\n\n\n@PyClass\nclass BatteryMonitor {\n\n    var _level_callback: PyPointer?\n    var _state_callback: PyPointer?\n\n    @PyInit\n    init(level_callback: PyPointer? = nil, state_callback: PyPointer? = nil) {\n        _level_callback = level_callback\n        _state_callback = state_callback\n\n        UIDevice.current.isBatteryMonitoringEnabled = true\n\n        // Register for battery level changes\n        NotificationCenter.default.addObserver(\n            self,\n            selector: #selector(batteryLevelChanged),\n            name: UIDevice.batteryLevelDidChangeNotification,\n            object: nil\n        )\n\n        // Register for battery state changes\n        NotificationCenter.default.addObserver(\n            self,\n            selector: #selector(batteryStateChanged),\n            name: UIDevice.batteryStateDidChangeNotification,\n            object: nil\n        )\n    }\n\n    @PyMethod\n    func get_battery_level() -&gt; Float {\n        return UIDevice.current.batteryLevel\n    }\n\n    @PyMethod\n    func get_battery_state() -&gt; String {\n        switch UIDevice.current.batteryState {\n        case .unknown:\n            return \"unknown\"\n        case .unplugged:\n            return \"unplugged\"\n        case .charging:\n            return \"charging\"\n        case .full:\n            return \"full\"\n        @unknown default:\n            return \"unknown\"\n        }\n    }\n\n    @objc func batteryLevelChanged(notification: NSNotification) {\n        level_changed_callback(level: UIDevice.current.batteryLevel)\n    }\n\n    @objc func batteryStateChanged(notification: NSNotification) {\n        state_changed_callback(state: get_battery_state())\n    }\n\n    /* \n    @PyCall will automatically fill out the function body.\n    By default, it targets a variable with an underscore prefix (_level_callback).\n    You can specify a different variable name using the name: parameter.\n    */\n    @PyCall\n    func level_changed_callback(level: Float)\n\n    @PyCall\n    func state_changed_callback(state: String)\n}\n\n@PyModule\nstruct battery_monitor: PyModuleProtocol {\n    static var py_classes: [any (PyClassProtocol &amp; AnyObject).Type] = [\n        BatteryMonitor.self\n    ]\n}\n</code></pre> main.py<pre><code>from battery_monitor import BatteryMonitor\n\ndef on_level_change(level: float):\n    print(f\"Battery level changed: {level * 100}%\")\n\ndef on_state_change(state: str):\n    print(f\"Battery state changed: {state}\")\n\n# Create monitor with callbacks\nmonitor = BatteryMonitor(\n    level_callback=on_level_change,\n    state_callback=on_state_change\n)\n\n# Callbacks will be triggered automatically when battery changes\n# (up to once per minute for level changes)\n\n# You can also use lambda functions\nmonitor = BatteryMonitor(\n    level_callback=lambda level: print(f\"Level: {level * 100}%\"),\n    state_callback=lambda state: print(f\"State: {state}\")\n)\n</code></pre>"},{"location":"wrapper_examples/battery_level/#batterymonitor-part-3","title":"BatteryMonitor Part 3","text":"<p>Make callback from Swift to Python by converting a Py-Function/Method into a Swift Function Closure:</p> <ul> <li>Pros<ul> <li>No need for storing a variable to call, that happens inside the closure.</li> <li>Cleaner API - callbacks are passed when needed rather than at initialization.</li> </ul> </li> <li>Cons</li> <li>By default the Swift closure can't keep a strong ref to the temporary object of the passed pyfunction, so it's important that one of the following conditions are met:         1. The callback should happen within the life cycle of the function that was passed to it.         2. If the callback is meant to be called later on, then it's important the pyfunction should be stored in Python as a strong ref that will keep the temporary object to the pyfunction alive while the callback is happening.</li> </ul> BatteryMonitor.swift<pre><code>import UIKit\nimport PySwiftKit\nimport PySerializing\nimport PySwiftObject\nimport PySwiftWrapper\n\n\n@PyClass\nclass BatteryMonitor {\n\n    @PyInit\n    init() {\n        UIDevice.current.isBatteryMonitoringEnabled = true\n    }\n\n    @PyMethod\n    func get_battery_level() -&gt; Float {\n        return UIDevice.current.batteryLevel\n    }\n\n    @PyMethod\n    func get_battery_state() -&gt; String {\n        switch UIDevice.current.batteryState {\n        case .unknown:\n            return \"unknown\"\n        case .unplugged:\n            return \"unplugged\"\n        case .charging:\n            return \"charging\"\n        case .full:\n            return \"full\"\n        @unknown default:\n            return \"unknown\"\n        }\n    }\n\n    @PyMethod\n    func monitor_changes(\n        level_callback: @escaping (Float) -&gt; Void,\n        state_callback: @escaping (String) -&gt; Void\n    ) {\n        // Register for battery level changes\n        NotificationCenter.default.addObserver(\n            forName: UIDevice.batteryLevelDidChangeNotification,\n            object: nil,\n            queue: .main\n        ) { _ in\n            // This matches condition 1 - callback happens within the notification handler\n            level_callback(UIDevice.current.batteryLevel)\n        }\n\n        // Register for battery state changes\n        NotificationCenter.default.addObserver(\n            forName: UIDevice.batteryStateDidChangeNotification,\n            object: nil,\n            queue: .main\n        ) { [weak self] _ in\n            guard let self = self else { return }\n            // This matches condition 1 - callback happens within the notification handler\n            state_callback(self.get_battery_state())\n        }\n    }\n}\n\n@PyModule\nstruct battery_monitor: PyModuleProtocol {\n    static var py_classes: [any (PyClassProtocol &amp; AnyObject).Type] = [\n        BatteryMonitor.self\n    ]\n}\n</code></pre> main.py<pre><code>from battery_monitor import BatteryMonitor\n\ndef on_level_change(level: float):\n    print(f\"Battery level changed: {level * 100}%\")\n\ndef on_state_change(state: str):\n    print(f\"Battery state changed: {state}\")\n\nmonitor = BatteryMonitor()\n\n# Start monitoring with callbacks\nmonitor.monitor_changes(on_level_change, on_state_change)\n\n# Or with lambda functions\nmonitor.monitor_changes(\n    lambda level: print(f\"Level: {level * 100}%\"),\n    lambda state: print(f\"State: {state}\")\n)\n\n# Get current status anytime\nprint(f\"Current level: {monitor.get_battery_level() * 100}%\")\nprint(f\"Current state: {monitor.get_battery_state()}\")\n</code></pre>"},{"location":"wrapper_examples/battery_level/#use-case-power-outage-detector","title":"Use Case: Power Outage Detector","text":"<p>A practical example of using this battery monitor to detect power outages:</p> power_outage_detector.py<pre><code>from battery_monitor import BatteryMonitor\nimport time\n\nclass PowerOutageDetector:\n    def __init__(self):\n        self.monitor = BatteryMonitor()\n        self.was_charging = self.monitor.get_battery_state() == \"charging\"\n\n    def start_monitoring(self):\n        def on_state_change(state: str):\n            if self.was_charging and state == \"unplugged\":\n                print(\"\u26a0\ufe0f POWER OUTAGE DETECTED!\")\n                # Send notification, save data, etc.\n            elif not self.was_charging and state == \"charging\":\n                print(\"\u2713 Power restored\")\n\n            self.was_charging = (state == \"charging\")\n\n        self.monitor.monitor_changes(\n            level_callback=lambda level: None,  # We don't need level updates\n            state_callback=on_state_change\n        )\n\n# Usage: Keep a spare phone plugged in running this script\ndetector = PowerOutageDetector()\ndetector.start_monitoring()\n\nprint(\"Monitoring for power outages...\")\nprint(f\"Current state: {detector.monitor.get_battery_state()}\")\n</code></pre>"},{"location":"wrapper_examples/device_info/","title":"Device info","text":""},{"location":"wrapper_examples/device_info/#getting-started","title":"Getting started","text":"<p>This tutorial demonstrates how to access iOS device information from Python using PythonSwiftLink. You'll learn how to retrieve device details such as the device name, model, system version, and unique identifier. This is useful for apps that need to display device information, perform device-specific logic, or collect analytics data.</p>"},{"location":"wrapper_examples/device_info/#deviceinfo-part-1","title":"DeviceInfo Part 1","text":"<p>Call Swift from Python to read device information:</p> <p>Let's start with a basic Swift class that accesses device information. iOS provides device details through <code>UIDevice.current</code>, which gives us access to various properties about the running device.</p> DeviceInfo.swift<pre><code>import UIKit\n\npublic class DeviceInfo {\n\n    init() {\n\n    }\n\n    func get_device_name() -&gt; String {\n        return UIDevice.current.name\n    }\n\n    func get_device_model() -&gt; String {\n        return UIDevice.current.model\n    }\n\n    func get_system_name() -&gt; String {\n        return UIDevice.current.systemName\n    }\n\n    func get_system_version() -&gt; String {\n        return UIDevice.current.systemVersion\n    }\n\n    func get_device_identifier() -&gt; String {\n        return UIDevice.current.identifierForVendor?.uuidString ?? \"N/A\"\n    }\n\n    func get_device_type() -&gt; String {\n        switch UIDevice.current.userInterfaceIdiom {\n        case .phone:\n            return \"iPhone\"\n        case .pad:\n            return \"iPad\"\n        case .tv:\n            return \"Apple TV\"\n        case .carPlay:\n            return \"CarPlay\"\n        case .mac:\n            return \"Mac\"\n        case .vision:\n            return \"Vision Pro\"\n        @unknown default:\n            return \"Unknown\"\n        }\n    }\n\n    func get_all_info() -&gt; [String: String] {\n        return [\n            \"name\": get_device_name(),\n            \"model\": get_device_model(),\n            \"system_name\": get_system_name(),\n            \"system_version\": get_system_version(),\n            \"identifier\": get_device_identifier(),\n            \"device_type\": get_device_type()\n        ]\n    }\n}\n</code></pre> <p>To make this Swift class accessible from Python, we need to add PySwiftKit decorators. The <code>@PyClass</code> decorator marks the class as exportable to Python, <code>@PyInit</code> wraps the initializer, and <code>@PyMethod</code> exposes methods to Python.</p> <p>Here's the same class with the necessary wrappers:</p> DeviceInfo.swift<pre><code>import UIKit\nimport PySwiftKit\nimport PySerializing\nimport PySwiftObject\nimport PySwiftWrapper\n\n\n@PyClass\nclass DeviceInfo {\n\n    @PyInit\n    init() {\n\n    }\n\n    @PyMethod\n    func get_device_name() -&gt; String {\n        return UIDevice.current.name\n    }\n\n    @PyMethod\n    func get_device_model() -&gt; String {\n        return UIDevice.current.model\n    }\n\n    @PyMethod\n    func get_system_name() -&gt; String {\n        return UIDevice.current.systemName\n    }\n\n    @PyMethod\n    func get_system_version() -&gt; String {\n        return UIDevice.current.systemVersion\n    }\n\n    @PyMethod\n    func get_device_identifier() -&gt; String {\n        return UIDevice.current.identifierForVendor?.uuidString ?? \"N/A\"\n    }\n\n    @PyMethod\n    func get_device_type() -&gt; String {\n        switch UIDevice.current.userInterfaceIdiom {\n        case .phone:\n            return \"iPhone\"\n        case .pad:\n            return \"iPad\"\n        case .tv:\n            return \"Apple TV\"\n        case .carPlay:\n            return \"CarPlay\"\n        case .mac:\n            return \"Mac\"\n        case .vision:\n            return \"Vision Pro\"\n        @unknown default:\n            return \"Unknown\"\n        }\n    }\n\n    @PyMethod\n    func get_all_info() -&gt; [String: String] {\n        return [\n            \"name\": get_device_name(),\n            \"model\": get_device_model(),\n            \"system_name\": get_system_name(),\n            \"system_version\": get_system_version(),\n            \"identifier\": get_device_identifier(),\n            \"device_type\": get_device_type()\n        ]\n    }\n}\n\n@PyModule\nstruct device_info: PyModuleProtocol {\n    static var py_classes: [any (PyClassProtocol &amp; AnyObject).Type] = [\n        DeviceInfo.self\n    ]\n}\n</code></pre> <p>The <code>@PyModule</code> struct defines a Python module named <code>device_info</code> that contains our DeviceInfo class. The <code>py_classes</code> array lists all classes that should be available in the module.</p> <p>Once compiled, this creates a Python module that can be imported and used like any native Python class:</p> device_info.py<pre><code>class DeviceInfo:\n\n    def __init__(self): ...\n\n    def get_device_name(self) -&gt; str: ...\n\n    def get_device_model(self) -&gt; str: ...\n\n    def get_system_name(self) -&gt; str: ...\n\n    def get_system_version(self) -&gt; str: ...\n\n    def get_device_identifier(self) -&gt; str: ...\n\n    def get_device_type(self) -&gt; str: ...\n\n    def get_all_info(self) -&gt; dict[str, str]: ...\n</code></pre>"},{"location":"wrapper_examples/device_info/#usage-examples","title":"Usage Examples","text":"<p>Here are various ways to use the DeviceInfo class in Python:</p> main.py<pre><code>from device_info import DeviceInfo\n\n# Create device info instance\ndevice = DeviceInfo()\n\n# Get individual properties\ndevice_name = device.get_device_name()\nprint(f\"Device Name: {device_name}\")\n\ndevice_model = device.get_device_model()\nprint(f\"Device Model: {device_model}\")\n\nsystem_name = device.get_system_name()\nprint(f\"System Name: {system_name}\")\n\nsystem_version = device.get_system_version()\nprint(f\"System Version: {system_version}\")\n\nidentifier = device.get_device_identifier()\nprint(f\"Device Identifier: {identifier}\")\n\ndevice_type = device.get_device_type()\nprint(f\"Device Type: {device_type}\")\n\n# Get all information at once\nall_info = device.get_all_info()\nprint(\"\\nAll Device Information:\")\nfor key, value in all_info.items():\n    print(f\"  {key}: {value}\")\n</code></pre> <p>Example output: <pre><code>Device Name: John's iPhone\nDevice Model: iPhone\nSystem Name: iOS\nSystem Version: 17.0\nDevice Identifier: 12345678-1234-1234-1234-123456789ABC\nDevice Type: iPhone\n\nAll Device Information:\n  name: John's iPhone\n  model: iPhone\n  system_name: iOS\n  system_version: 17.0\n  identifier: 12345678-1234-1234-1234-123456789ABC\n  device_type: iPhone\n</code></pre></p>"},{"location":"wrapper_examples/device_info/#use-cases","title":"Use Cases","text":""},{"location":"wrapper_examples/device_info/#device-specific-logic","title":"Device-Specific Logic","text":"adaptive_ui.py<pre><code>from device_info import DeviceInfo\n\ndevice = DeviceInfo()\n\n# Adjust UI based on device type\ndevice_type = device.get_device_type()\n\nif device_type == \"iPhone\":\n    # Use compact UI layout\n    print(\"Using compact iPhone layout\")\nelif device_type == \"iPad\":\n    # Use larger UI layout\n    print(\"Using expanded iPad layout\")\nelif device_type == \"Vision Pro\":\n    # Use spatial UI\n    print(\"Using spatial Vision Pro layout\")\n</code></pre>"},{"location":"wrapper_examples/device_info/#system-version-check","title":"System Version Check","text":"version_check.py<pre><code>from device_info import DeviceInfo\n\ndevice = DeviceInfo()\n\n# Check if device meets minimum requirements\nsystem_version = device.get_system_version()\nmajor_version = int(system_version.split('.')[0])\n\nMIN_IOS_VERSION = 15\n\nif major_version &gt;= MIN_IOS_VERSION:\n    print(f\"\u2713 iOS {system_version} is supported\")\nelse:\n    print(f\"\u2717 iOS {system_version} is not supported. Please upgrade to iOS {MIN_IOS_VERSION}+\")\n</code></pre>"},{"location":"wrapper_examples/device_info/#analytics-and-logging","title":"Analytics and Logging","text":"analytics.py<pre><code>from device_info import DeviceInfo\nimport json\n\ndevice = DeviceInfo()\n\n# Collect device info for analytics\ndef collect_analytics():\n    info = device.get_all_info()\n\n    analytics_data = {\n        \"device_info\": info,\n        \"app_version\": \"1.0.0\",\n        \"timestamp\": \"2025-11-13T12:00:00Z\"\n    }\n\n    # Send to analytics service\n    print(\"Analytics Data:\")\n    print(json.dumps(analytics_data, indent=2))\n\ncollect_analytics()\n</code></pre>"},{"location":"wrapper_examples/device_info/#device-information-display","title":"Device Information Display","text":"about_screen.py<pre><code>from device_info import DeviceInfo\n\nclass AboutScreen:\n    def __init__(self):\n        self.device = DeviceInfo()\n\n    def display_info(self):\n        info = self.device.get_all_info()\n\n        print(\"=\" * 40)\n        print(\"DEVICE INFORMATION\")\n        print(\"=\" * 40)\n        print(f\"Device:      {info['name']}\")\n        print(f\"Model:       {info['model']}\")\n        print(f\"Type:        {info['device_type']}\")\n        print(f\"OS:          {info['system_name']} {info['system_version']}\")\n        print(f\"Identifier:  {info['identifier']}\")\n        print(\"=\" * 40)\n\n# Usage\nabout = AboutScreen()\nabout.display_info()\n</code></pre>"},{"location":"wrapper_examples/device_info/#important-notes","title":"Important Notes","text":"<p>Identifier for Vendor</p> <p>The device identifier returned by <code>get_device_identifier()</code> is the <code>identifierForVendor</code>, which is unique to your app on this device. It will be the same across all apps from the same vendor, but different from other vendors' apps.</p> <p>Privacy Considerations</p> <ul> <li>The device identifier can change if the user uninstalls all apps from your vendor and then reinstalls</li> <li>Device identifiers should be handled according to privacy regulations</li> <li>Never use device identifiers as the sole method for user authentication</li> </ul> <p>Device Type Detection</p> <p>The <code>get_device_type()</code> method returns a human-readable string that's perfect for display purposes or simple device-specific logic. For more complex device detection, you may want to extend this class with additional methods.</p>"},{"location":"wrapper_examples/firebase_auth/","title":"Firebase Authentication &amp; Database","text":""},{"location":"wrapper_examples/firebase_auth/#getting-started","title":"Getting started","text":"<p>This tutorial demonstrates how to integrate Firebase Authentication and Realtime Database from Python using PythonSwiftLink. You'll learn how to implement user sign-in, sign-up, and save user data to Firebase. This is essential for building apps that require user authentication and data persistence in the cloud.</p>"},{"location":"wrapper_examples/firebase_auth/#prerequisites","title":"Prerequisites","text":"<p>Before starting, ensure you have:</p> <ol> <li>Firebase configured in your Xcode project</li> <li>Firebase SDK installed via Swift Package Manager or CocoaPods</li> <li><code>GoogleService-Info.plist</code> added to your project</li> </ol>"},{"location":"wrapper_examples/firebase_auth/#firebaseauth-part-1","title":"FirebaseAuth Part 1","text":"<p>Basic Firebase authentication with email and password:</p> <p>Let's start with a Swift class that handles Firebase authentication. This class will manage user sign-in, sign-up, and user profile creation in the Firebase Realtime Database.</p> FirebaseAuthManager.swift<pre><code>import UIKit\nimport FirebaseAuth\nimport FirebaseDatabase\n\npublic class FirebaseAuthManager {\n\n    var ref: DatabaseReference!\n\n    init() {\n        ref = Database.database().reference()\n    }\n\n    func sign_in(email: String, password: String, completion: @escaping (Bool, String?) -&gt; Void) {\n        Auth.auth().signIn(withEmail: email, password: password) { authResult, error in\n            guard let user = authResult?.user, error == nil else {\n                completion(false, error?.localizedDescription)\n                return\n            }\n            completion(true, user.uid)\n        }\n    }\n\n    func sign_up(email: String, password: String, username: String, completion: @escaping (Bool, String?) -&gt; Void) {\n        Auth.auth().createUser(withEmail: email, password: password) { authResult, error in\n            guard let user = authResult?.user, error == nil else {\n                completion(false, error?.localizedDescription)\n                return\n            }\n\n            // Save username to database\n            self.save_user_info(user: user, username: username) { success in\n                completion(success, user.uid)\n            }\n        }\n    }\n\n    func save_user_info(user: User, username: String, completion: @escaping (Bool) -&gt; Void) {\n        // Set display name\n        let changeRequest = user.createProfileChangeRequest()\n        changeRequest.displayName = username\n\n        changeRequest.commitChanges { error in\n            if let error = error {\n                print(\"Error updating profile: \\(error.localizedDescription)\")\n                completion(false)\n                return\n            }\n\n            // Save to database\n            self.ref.child(\"users\").child(user.uid).setValue([\"username\": username])\n            completion(true)\n        }\n    }\n\n    func sign_out() -&gt; Bool {\n        do {\n            try Auth.auth().signOut()\n            return true\n        } catch let error {\n            print(\"Error signing out: \\(error.localizedDescription)\")\n            return false\n        }\n    }\n\n    func get_current_user_id() -&gt; String? {\n        return Auth.auth().currentUser?.uid\n    }\n\n    func get_current_user_email() -&gt; String? {\n        return Auth.auth().currentUser?.email\n    }\n\n    func get_current_user_display_name() -&gt; String? {\n        return Auth.auth().currentUser?.displayName\n    }\n}\n</code></pre> <p>To make this accessible from Python, add PySwiftKit decorators:</p> FirebaseAuthManager.swift<pre><code>import UIKit\nimport FirebaseAuth\nimport FirebaseDatabase\nimport PySwiftKit\nimport PySerializing\nimport PySwiftObject\nimport PySwiftWrapper\n\n\n@PyClass\nclass FirebaseAuthManager {\n\n    var ref: DatabaseReference!\n    var _sign_in_callback: PyPointer?\n    var _sign_up_callback: PyPointer?\n\n    @PyInit\n    init(sign_in_callback: PyPointer? = nil, sign_up_callback: PyPointer? = nil) {\n        ref = Database.database().reference()\n        _sign_in_callback = sign_in_callback\n        _sign_up_callback = sign_up_callback\n    }\n\n    @PyMethod\n    func sign_in(email: String, password: String) {\n        Auth.auth().signIn(withEmail: email, password: password) { authResult, error in\n            guard let user = authResult?.user, error == nil else {\n                self.on_sign_in_complete(success: false, user_id: nil, error: error?.localizedDescription ?? \"Unknown error\")\n                return\n            }\n\n            // Check if user exists in database\n            self.ref.child(\"users\").child(user.uid).observeSingleEvent(of: .value) { snapshot in\n                if snapshot.exists() {\n                    self.on_sign_in_complete(success: true, user_id: user.uid, error: nil)\n                } else {\n                    self.on_sign_in_complete(success: false, user_id: nil, error: \"User profile not found\")\n                }\n            }\n        }\n    }\n\n    @PyMethod\n    func sign_up(email: String, password: String, username: String) {\n        Auth.auth().createUser(withEmail: email, password: password) { authResult, error in\n            guard let user = authResult?.user, error == nil else {\n                self.on_sign_up_complete(success: false, user_id: nil, error: error?.localizedDescription ?? \"Unknown error\")\n                return\n            }\n\n            // Save user info\n            self.save_user_info(user: user, username: username)\n        }\n    }\n\n    func save_user_info(user: User, username: String) {\n        let changeRequest = user.createProfileChangeRequest()\n        changeRequest.displayName = username\n\n        changeRequest.commitChanges { error in\n            if let error = error {\n                self.on_sign_up_complete(success: false, user_id: nil, error: error.localizedDescription)\n                return\n            }\n\n            // Save to database\n            self.ref.child(\"users\").child(user.uid).setValue([\"username\": username])\n            self.on_sign_up_complete(success: true, user_id: user.uid, error: nil)\n        }\n    }\n\n    @PyMethod\n    func sign_out() -&gt; Bool {\n        do {\n            try Auth.auth().signOut()\n            return true\n        } catch let error {\n            print(\"Error signing out: \\(error.localizedDescription)\")\n            return false\n        }\n    }\n\n    @PyMethod\n    func get_current_user_id() -&gt; String {\n        return Auth.auth().currentUser?.uid ?? \"\"\n    }\n\n    @PyMethod\n    func get_current_user_email() -&gt; String {\n        return Auth.auth().currentUser?.email ?? \"\"\n    }\n\n    @PyMethod\n    func get_current_user_display_name() -&gt; String {\n        return Auth.auth().currentUser?.displayName ?? \"\"\n    }\n\n    @PyMethod\n    func is_signed_in() -&gt; Bool {\n        return Auth.auth().currentUser != nil\n    }\n\n    // Callback methods\n    @PyCall\n    func on_sign_in_complete(success: Bool, user_id: String?, error: String?)\n\n    @PyCall\n    func on_sign_up_complete(success: Bool, user_id: String?, error: String?)\n}\n\n@PyModule\nstruct firebase_auth: PyModuleProtocol {\n    static var py_classes: [any (PyClassProtocol &amp; AnyObject).Type] = [\n        FirebaseAuthManager.self\n    ]\n}\n</code></pre> <p>The <code>@PyModule</code> struct creates a Python module named <code>firebase_auth</code> containing the FirebaseAuthManager class.</p> <p>Once compiled, this creates a Python module:</p> firebase_auth.py<pre><code>class FirebaseAuthManager:\n\n    def __init__(self, sign_in_callback: object = None, sign_up_callback: object = None): ...\n\n    def sign_in(self, email: str, password: str): ...\n\n    def sign_up(self, email: str, password: str, username: str): ...\n\n    def sign_out(self) -&gt; bool: ...\n\n    def get_current_user_id(self) -&gt; str: ...\n\n    def get_current_user_email(self) -&gt; str: ...\n\n    def get_current_user_display_name(self) -&gt; str: ...\n\n    def is_signed_in(self) -&gt; bool: ...\n</code></pre>"},{"location":"wrapper_examples/firebase_auth/#usage-examples","title":"Usage Examples","text":""},{"location":"wrapper_examples/firebase_auth/#basic-sign-insign-up","title":"Basic Sign In/Sign Up","text":"main.py<pre><code>from firebase_auth import FirebaseAuthManager\n\n# Callback handlers\ndef on_sign_in(success: bool, user_id: str, error: str):\n    if success:\n        print(f\"\u2713 Sign in successful! User ID: {user_id}\")\n    else:\n        print(f\"\u2717 Sign in failed: {error}\")\n\ndef on_sign_up(success: bool, user_id: str, error: str):\n    if success:\n        print(f\"\u2713 Sign up successful! User ID: {user_id}\")\n    else:\n        print(f\"\u2717 Sign up failed: {error}\")\n\n# Create auth manager with callbacks\nauth = FirebaseAuthManager(\n    sign_in_callback=on_sign_in,\n    sign_up_callback=on_sign_up\n)\n\n# Sign up new user\nauth.sign_up(\n    email=\"user@example.com\",\n    password=\"secure_password123\",\n    username=\"john_doe\"\n)\n\n# Sign in existing user\nauth.sign_in(\n    email=\"user@example.com\",\n    password=\"secure_password123\"\n)\n\n# Check current user\nif auth.is_signed_in():\n    print(f\"Current user: {auth.get_current_user_display_name()}\")\n    print(f\"Email: {auth.get_current_user_email()}\")\n    print(f\"ID: {auth.get_current_user_id()}\")\n\n# Sign out\nif auth.sign_out():\n    print(\"Successfully signed out\")\n</code></pre>"},{"location":"wrapper_examples/firebase_auth/#login-screen-example","title":"Login Screen Example","text":"login_screen.py<pre><code>from firebase_auth import FirebaseAuthManager\n\nclass LoginScreen:\n    def __init__(self):\n        self.auth = FirebaseAuthManager(\n            sign_in_callback=self.handle_sign_in,\n            sign_up_callback=self.handle_sign_up\n        )\n        self.current_user_id = None\n\n    def handle_sign_in(self, success: bool, user_id: str, error: str):\n        if success:\n            self.current_user_id = user_id\n            print(f\"Welcome back, {self.auth.get_current_user_display_name()}!\")\n            self.navigate_to_home()\n        else:\n            self.show_error(f\"Login failed: {error}\")\n\n    def handle_sign_up(self, success: bool, user_id: str, error: str):\n        if success:\n            self.current_user_id = user_id\n            print(f\"Account created for {self.auth.get_current_user_display_name()}\")\n            self.navigate_to_home()\n        else:\n            self.show_error(f\"Sign up failed: {error}\")\n\n    def login(self, email: str, password: str):\n        if not email or not password:\n            self.show_error(\"Email and password cannot be empty\")\n            return\n        self.auth.sign_in(email, password)\n\n    def register(self, email: str, password: str, username: str):\n        if not email or not password or not username:\n            self.show_error(\"All fields are required\")\n            return\n        self.auth.sign_up(email, password, username)\n\n    def logout(self):\n        if self.auth.sign_out():\n            self.current_user_id = None\n            print(\"Logged out successfully\")\n            self.navigate_to_login()\n\n    def show_error(self, message: str):\n        print(f\"Error: {message}\")\n\n    def navigate_to_home(self):\n        print(\"Navigating to home screen...\")\n\n    def navigate_to_login(self):\n        print(\"Navigating to login screen...\")\n\n# Usage\nlogin = LoginScreen()\n\n# User tries to sign up\nlogin.register(\n    email=\"newuser@example.com\",\n    password=\"password123\",\n    username=\"new_user\"\n)\n\n# User tries to login\nlogin.login(\n    email=\"newuser@example.com\",\n    password=\"password123\"\n)\n\n# User logs out\nlogin.logout()\n</code></pre>"},{"location":"wrapper_examples/firebase_auth/#user-session-manager","title":"User Session Manager","text":"session_manager.py<pre><code>from firebase_auth import FirebaseAuthManager\n\nclass SessionManager:\n    _instance = None\n\n    def __new__(cls):\n        if cls._instance is None:\n            cls._instance = super().__new__(cls)\n            cls._instance.auth = FirebaseAuthManager()\n        return cls._instance\n\n    def check_session(self) -&gt; bool:\n        \"\"\"Check if user is currently logged in\"\"\"\n        return self.auth.is_signed_in()\n\n    def get_user_info(self) -&gt; dict:\n        \"\"\"Get current user information\"\"\"\n        if not self.check_session():\n            return {}\n\n        return {\n            \"user_id\": self.auth.get_current_user_id(),\n            \"email\": self.auth.get_current_user_email(),\n            \"display_name\": self.auth.get_current_user_display_name()\n        }\n\n    def require_auth(self, func):\n        \"\"\"Decorator to require authentication\"\"\"\n        def wrapper(*args, **kwargs):\n            if not self.check_session():\n                print(\"Authentication required\")\n                return None\n            return func(*args, **kwargs)\n        return wrapper\n\n# Usage\nsession = SessionManager()\n\n@session.require_auth\ndef get_protected_data():\n    user_info = session.get_user_info()\n    print(f\"Fetching data for: {user_info['display_name']}\")\n    return {\"data\": \"sensitive information\"}\n\n# Check session\nif session.check_session():\n    user = session.get_user_info()\n    print(f\"Logged in as: {user['display_name']} ({user['email']})\")\nelse:\n    print(\"No active session\")\n\n# Try to access protected function\nresult = get_protected_data()\n</code></pre>"},{"location":"wrapper_examples/firebase_auth/#important-notes","title":"Important Notes","text":"<p>Firebase Configuration</p> <p>Make sure to initialize Firebase in your app's <code>AppDelegate</code> or <code>@main</code> entry point:</p> <pre><code>import FirebaseCore\n\n@main\nclass AppDelegate: UIResponder, UIApplicationDelegate {\n    func application(_ application: UIApplication,\n                    didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool {\n        FirebaseApp.configure()\n        return true\n    }\n}\n</code></pre> <p>Async Operations</p> <p>Firebase authentication operations are asynchronous. Results are delivered through callbacks (<code>on_sign_in_complete</code>, <code>on_sign_up_complete</code>). Make sure to handle these callbacks appropriately in your Python code.</p> <p>Error Handling</p> <p>Always check the <code>success</code> parameter in callbacks before accessing <code>user_id</code>. The <code>error</code> parameter contains the error message when <code>success</code> is <code>false</code>.</p> <p>Database Structure</p> <p>This example saves user data in the following structure: <pre><code>users/\n  \u2514\u2500\u2500 &lt;user_id&gt;/\n        \u2514\u2500\u2500 username: \"user_display_name\"\n</code></pre></p> <p>You can extend this structure to include more user profile information.</p> <p>Security Rules</p> <p>Remember to configure Firebase Realtime Database security rules appropriately. For development, you might use:</p> <pre><code>{\n  \"rules\": {\n    \"users\": {\n      \"$uid\": {\n        \".read\": \"$uid === auth.uid\",\n        \".write\": \"$uid === auth.uid\"\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"wrapper_examples/hello_world/","title":"Hello world","text":""},{"location":"wrapper_examples/hello_world/#getting-started","title":"Getting started","text":"<p>This tutorial demonstrates how to create a Swift class that can be called from Python using PythonSwiftLink. You'll learn how to wrap Swift code to make it accessible from Python, including passing data between the two languages and implementing callbacks. We'll build a simple HelloWorld class that showcases the fundamental patterns you'll use when bridging Swift and Python code.</p>"},{"location":"wrapper_examples/hello_world/#helloworld-part-1","title":"HelloWorld Part 1","text":"<p>Call Swift from Python:</p> <p>Let's start with a basic Swift class that we want to use from Python. This class has a simple method that prints a string to the console.</p> HelloWorld.swift<pre><code>public class HelloWorld {\n\n    init() {\n\n    }\n\n    func send_string(text: String) {\n        print(text)\n    }\n\n}\n</code></pre> <p>To make this Swift class accessible from Python, we need to add PySwiftKit decorators. The <code>@PyClass</code> decorator marks the class as exportable to Python, <code>@PyInit</code> wraps the initializer, and <code>@PyMethod</code> exposes methods to Python. We also need to define a module structure using <code>@PyModule</code> that lists all the classes we want to export.</p> <p>Here's the same class with the necessary wrappers:</p> HelloWorld.swift<pre><code>import PySwiftKit\nimport PySerializing\nimport PySwiftObject\nimport PySwiftWrapper\n\n\n@PyClass\nclass HelloWorld {\n\n    @PyInit\n    init() {\n\n    }\n\n    @PyMethod\n    func send_string(text: String) {\n        print(text)\n    }\n\n}\n\n@PyModule\nstruct hello_world: PyModuleProtocol {\n    static var py_classes: [any (PyClassProtocol &amp; AnyObject).Type] = [\n        HelloWorld.self\n    ]\n}\n</code></pre> <p>The <code>@PyModule</code> struct defines a Python module named <code>hello_world</code> that contains our HelloWorld class. The <code>py_classes</code> array lists all classes that should be available in the module.</p> <p>Once compiled, this creates a Python module that can be imported and used like any native Python class:</p> hello_world.py<pre><code>class HelloWorld:\n\n    def __init__(self)...\n\n    def send_string(self, text: str): ...\n</code></pre>"},{"location":"wrapper_examples/hello_world/#helloworld-part-2","title":"HelloWorld Part 2","text":"<p>Now let's explore how to implement callbacks from Swift back to Python. This is useful when you want Swift code to notify Python about events or results. We'll pass a Python function to Swift and call it from within a Swift method.</p> <p>Make callback from Swift to Python:</p> HelloWorld.swift<pre><code>@PyClass\nclass HelloWorld {\n\n    var _callback: PyPointer\n\n    @PyInit\n    init(callback: PyPointer) {\n        _callback = callback\n    }\n\n    @PyMethod\n    func send_string(text: String) {\n        callback(\n            text + \" World\"\n        )\n    }\n\n    /* \n    {} is not needed, PyCall will automatic fill out the function body\n    by default PyCall will target a variable that should be a underscored name\n    of the function, this case _callback.\n    but you can use the name: \"another_name\" in the argument input on @PyCall\n    to target another name.\n    */\n    @PyCall \n    func callback(text: String)\n\n}\n</code></pre> main.py<pre><code>from hello_world import HelloWorld\n\ndef callback(text: str):\n    print(text)\n\nhw = HelloWorld(callback)\nhw.send_string(\"Hello\")\n\nhw = HelloWorld(lambda text: print(text))\nhw.send_string(\"Hello\")\n</code></pre>"},{"location":"wrapper_examples/hello_world/#helloworld-part-3","title":"HelloWorld Part 3","text":"<p>Make callback from Swift to Python by converting a Py-Function/Method into a Swift Function Closure:</p> <ul> <li>Pros<ul> <li>No need for storing a variable to call, that happens inside the closure.</li> </ul> </li> <li>Cons</li> <li>By default the swift closure can't keep a strong ref to the temporary     object of passed pyfunction. so its important that one of the following conditions are meet         1. The callback should happen within the life cycle of the function that was passed to it.         2. If the callback is ment to be called later on, then its importamt the pyfunction should be stored in python as a strongref that will keep the temporary object to the pyfunction alive, while callback is happening.</li> </ul> HelloWorld.swift<pre><code>@PyClass\nclass HelloWorld2 {\n\n    @PyInit\n    init() {\n\n    }\n\n    @PyMethod\n    func send_string(text: String, callback: @escaping (String)-&gt;Void) {\n        // this matches condition 1\n        callback(\n            text + \" World\"\n        )\n    }\n\n}\n</code></pre> main.py<pre><code>from hello_world import HelloWorld\n\ndef callback(text: str):\n    print(text)\n\nhw = HelloWorld()\n\nhw.send_string(\"Hello\", callback)\n\nhw.send_string(\"Hello\", lambda text: print(text))\n</code></pre>"},{"location":"wrapper_examples/uikit_viewcontroller/","title":"UIKit ViewController","text":"<p>This example demonstrates how to wrap UIKit ViewControllers and present them from Python. It shows how to create custom view controllers, configure their UI, and handle presentation/dismissal with callbacks.</p>"},{"location":"wrapper_examples/uikit_viewcontroller/#getting-started","title":"Getting Started","text":"<p>UIKit is Apple's primary framework for building user interfaces on iOS. This example covers:</p> <ul> <li>UIViewController - The base class for managing view hierarchies</li> <li>UILabel, UIButton - Basic UI components</li> <li>Modal Presentation - Showing view controllers</li> <li>Delegates/Callbacks - Handling user interactions and dismissal</li> </ul>"},{"location":"wrapper_examples/uikit_viewcontroller/#part-1-basic-swift-implementation","title":"Part 1: Basic Swift Implementation","text":"<p>First, here's a basic Swift implementation without PySwiftKit:</p> <pre><code>import UIKit\n\nclass CustomViewController: UIViewController {\n    var messageLabel: UILabel!\n    var closeButton: UIButton!\n\n    var message: String = \"Hello from Swift!\"\n    var onDismiss: (() -&gt; Void)?\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n\n        view.backgroundColor = .systemBackground\n\n        // Create and configure label\n        messageLabel = UILabel()\n        messageLabel.text = message\n        messageLabel.textAlignment = .center\n        messageLabel.font = .systemFont(ofSize: 24, weight: .bold)\n        messageLabel.translatesAutoresizingMaskIntoConstraints = false\n        view.addSubview(messageLabel)\n\n        // Create and configure button\n        closeButton = UIButton(type: .system)\n        closeButton.setTitle(\"Close\", for: .normal)\n        closeButton.titleLabel?.font = .systemFont(ofSize: 18)\n        closeButton.addTarget(self, action: #selector(closeButtonTapped), for: .touchUpInside)\n        closeButton.translatesAutoresizingMaskIntoConstraints = false\n        view.addSubview(closeButton)\n\n        // Layout constraints\n        NSLayoutConstraint.activate([\n            messageLabel.centerXAnchor.constraint(equalTo: view.centerXAnchor),\n            messageLabel.centerYAnchor.constraint(equalTo: view.centerYAnchor, constant: -50),\n            messageLabel.leadingAnchor.constraint(greaterThanOrEqualTo: view.leadingAnchor, constant: 20),\n            messageLabel.trailingAnchor.constraint(lessThanOrEqualTo: view.trailingAnchor, constant: -20),\n\n            closeButton.centerXAnchor.constraint(equalTo: view.centerXAnchor),\n            closeButton.topAnchor.constraint(equalTo: messageLabel.bottomAnchor, constant: 30),\n            closeButton.widthAnchor.constraint(equalToConstant: 100),\n            closeButton.heightAnchor.constraint(equalToConstant: 44)\n        ])\n    }\n\n    @objc func closeButtonTapped() {\n        dismiss(animated: true) {\n            self.onDismiss?()\n        }\n    }\n}\n\n// Helper to present the view controller\nclass ViewControllerPresenter {\n    static func present(_ viewController: UIViewController, animated: Bool = true) {\n        if let windowScene = UIApplication.shared.connectedScenes.first as? UIWindowScene,\n           let rootViewController = windowScene.windows.first?.rootViewController {\n            rootViewController.present(viewController, animated: animated)\n        }\n    }\n}\n</code></pre> <p>This creates a simple view controller with a label and close button, and provides a way to present it.</p>"},{"location":"wrapper_examples/uikit_viewcontroller/#part-2-swift-with-pyswiftkit","title":"Part 2: Swift with PySwiftKit","text":"<p>Now let's wrap it with PySwiftKit decorators:</p> <pre><code>import UIKit\nimport PythonSwiftLink\n\n@PyClass\nclass CustomViewController: UIViewController {\n    private var messageLabel: UILabel!\n    private var closeButton: UIButton!\n\n    private var message: String = \"Hello from Swift!\"\n    private var dismissCallback: PyPointer?\n\n    @PyInit\n    convenience init() {\n        self.init(nibName: nil, bundle: nil)\n    }\n\n    @PyMethod\n    func set_message(_ newMessage: String) {\n        message = newMessage\n        if isViewLoaded {\n            messageLabel.text = newMessage\n        }\n    }\n\n    @PyMethod\n    func get_message() -&gt; String {\n        return message\n    }\n\n    @PyMethod\n    func set_dismiss_callback(_ callback: PyPointer) {\n        dismissCallback = callback\n    }\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n\n        view.backgroundColor = .systemBackground\n\n        // Create and configure label\n        messageLabel = UILabel()\n        messageLabel.text = message\n        messageLabel.textAlignment = .center\n        messageLabel.font = .systemFont(ofSize: 24, weight: .bold)\n        messageLabel.numberOfLines = 0\n        messageLabel.translatesAutoresizingMaskIntoConstraints = false\n        view.addSubview(messageLabel)\n\n        // Create and configure button\n        closeButton = UIButton(type: .system)\n        closeButton.setTitle(\"Close\", for: .normal)\n        closeButton.titleLabel?.font = .systemFont(ofSize: 18)\n        closeButton.addTarget(self, action: #selector(closeButtonTapped), for: .touchUpInside)\n        closeButton.translatesAutoresizingMaskIntoConstraints = false\n        view.addSubview(closeButton)\n\n        // Layout constraints\n        NSLayoutConstraint.activate([\n            messageLabel.centerXAnchor.constraint(equalTo: view.centerXAnchor),\n            messageLabel.centerYAnchor.constraint(equalTo: view.centerYAnchor, constant: -50),\n            messageLabel.leadingAnchor.constraint(equalTo: view.leadingAnchor, constant: 20),\n            messageLabel.trailingAnchor.constraint(equalTo: view.trailingAnchor, constant: -20),\n\n            closeButton.centerXAnchor.constraint(equalTo: view.centerXAnchor),\n            closeButton.topAnchor.constraint(equalTo: messageLabel.bottomAnchor, constant: 30),\n            closeButton.widthAnchor.constraint(equalToConstant: 100),\n            closeButton.heightAnchor.constraint(equalToConstant: 44)\n        ])\n    }\n\n    @objc private func closeButtonTapped() {\n        dismiss(animated: true) { [weak self] in\n            guard let self = self, let callback = self.dismissCallback else { return }\n            callback.call()\n        }\n    }\n}\n\n@PyClass\nclass ViewControllerPresenter {\n\n    @PyInit\n    init() {}\n\n    @PyMethod\n    func present_view_controller(_ viewController: UIViewController, animated: Bool = true) {\n        DispatchQueue.main.async {\n            if let windowScene = UIApplication.shared.connectedScenes.first as? UIWindowScene,\n               let rootViewController = windowScene.windows.first?.rootViewController {\n                rootViewController.present(viewController, animated: animated)\n            }\n        }\n    }\n\n    @PyMethod\n    func present_custom_view_controller(_ message: String, animated: Bool = true, callback: PyPointer?) -&gt; CustomViewController {\n        let vc = CustomViewController()\n        vc.set_message(message)\n        if let cb = callback {\n            vc.set_dismiss_callback(cb)\n        }\n\n        DispatchQueue.main.async {\n            self.present_view_controller(vc, animated: animated)\n        }\n\n        return vc\n    }\n\n    @PyMethod\n    func dismiss_view_controller(animated: Bool = true, completion: PyPointer?) {\n        DispatchQueue.main.async {\n            if let windowScene = UIApplication.shared.connectedScenes.first as? UIWindowScene,\n               let rootViewController = windowScene.windows.first?.rootViewController {\n                rootViewController.dismiss(animated: animated) {\n                    completion?.call()\n                }\n            }\n        }\n    }\n\n    @PyMethod\n    static func get_root_view_controller() -&gt; UIViewController? {\n        if let windowScene = UIApplication.shared.connectedScenes.first as? UIWindowScene {\n            return windowScene.windows.first?.rootViewController\n        }\n        return nil\n    }\n}\n\n@PyModule\nclass UIKitModule {\n    static func registerTypes() {\n        CustomViewController.register()\n        ViewControllerPresenter.register()\n    }\n}\n</code></pre> <p>UIKit Thread Safety</p> <p>All UI operations in UIKit must happen on the main thread. This is why we wrap presentation calls in <code>DispatchQueue.main.async</code>. PySwiftKit handles this automatically for most operations, but it's good practice to be explicit.</p>"},{"location":"wrapper_examples/uikit_viewcontroller/#part-3-python-interface","title":"Part 3: Python Interface","text":"<p>Define the Python interface for presenting view controllers:</p> <pre><code>from typing import Optional, Callable\n\nclass CustomViewController:\n    \"\"\"A custom UIViewController with a message and close button.\"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize a new CustomViewController.\"\"\"\n        ...\n\n    def set_message(self, message: str) -&gt; None:\n        \"\"\"\n        Set the message displayed in the view controller.\n\n        Args:\n            message: The text to display\n        \"\"\"\n        ...\n\n    def get_message(self) -&gt; str:\n        \"\"\"\n        Get the current message.\n\n        Returns:\n            The current message text\n        \"\"\"\n        ...\n\n    def set_dismiss_callback(self, callback: Callable[[], None]) -&gt; None:\n        \"\"\"\n        Set a callback to be called when the view controller is dismissed.\n\n        Args:\n            callback: Function to call on dismissal\n        \"\"\"\n        ...\n\n\nclass ViewControllerPresenter:\n    \"\"\"Helper class for presenting UIKit view controllers.\"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize the presenter.\"\"\"\n        ...\n\n    def present_view_controller(\n        self, \n        view_controller: 'UIViewController', \n        animated: bool = True\n    ) -&gt; None:\n        \"\"\"\n        Present any UIViewController.\n\n        Args:\n            view_controller: The view controller to present\n            animated: Whether to animate the presentation\n        \"\"\"\n        ...\n\n    def present_custom_view_controller(\n        self,\n        message: str,\n        animated: bool = True,\n        callback: Optional[Callable[[], None]] = None\n    ) -&gt; CustomViewController:\n        \"\"\"\n        Create and present a CustomViewController.\n\n        Args:\n            message: The message to display\n            animated: Whether to animate the presentation\n            callback: Optional callback for when dismissed\n\n        Returns:\n            The created view controller instance\n        \"\"\"\n        ...\n\n    def dismiss_view_controller(\n        self,\n        animated: bool = True,\n        completion: Optional[Callable[[], None]] = None\n    ) -&gt; None:\n        \"\"\"\n        Dismiss the currently presented view controller.\n\n        Args:\n            animated: Whether to animate the dismissal\n            completion: Optional callback after dismissal\n        \"\"\"\n        ...\n\n    @staticmethod\n    def get_root_view_controller() -&gt; Optional['UIViewController']:\n        \"\"\"\n        Get the root view controller of the application.\n\n        Returns:\n            The root view controller or None\n        \"\"\"\n        ...\n</code></pre>"},{"location":"wrapper_examples/uikit_viewcontroller/#usage-example","title":"Usage Example","text":"<pre><code>from uikit_wrapper import ViewControllerPresenter, CustomViewController\nimport time\n\n# Create a presenter\npresenter = ViewControllerPresenter()\n\n# Example 1: Present a simple view controller\ndef on_dismiss():\n    print(\"View controller was dismissed!\")\n\nvc = presenter.present_custom_view_controller(\n    message=\"Hello from Python!\",\n    animated=True,\n    callback=on_dismiss\n)\n\n# Wait a bit, then update the message\ntime.sleep(2)\nvc.set_message(\"Message updated from Python!\")\n\n# Example 2: Create view controller first, configure, then present\nvc2 = CustomViewController()\nvc2.set_message(\"Pre-configured message\")\nvc2.set_dismiss_callback(lambda: print(\"VC2 dismissed\"))\n\npresenter.present_view_controller(vc2, animated=True)\n\n# Example 3: Dismiss programmatically\ntime.sleep(3)\npresenter.dismiss_view_controller(\n    animated=True,\n    completion=lambda: print(\"Dismissal complete\")\n)\n</code></pre>"},{"location":"wrapper_examples/uikit_viewcontroller/#advanced-usage-alert-dialog-wrapper","title":"Advanced Usage: Alert Dialog Wrapper","text":"<pre><code>from uikit_wrapper import ViewControllerPresenter\n\nclass AlertDialog:\n    \"\"\"Wrapper for presenting UIAlertController-style dialogs.\"\"\"\n\n    def __init__(self):\n        self.presenter = ViewControllerPresenter()\n\n    def show_message(\n        self,\n        title: str,\n        message: str,\n        button_text: str = \"OK\",\n        callback: callable = None\n    ):\n        \"\"\"Show a simple message dialog.\"\"\"\n        def on_dismiss():\n            print(f\"Alert dismissed: {title}\")\n            if callback:\n                callback()\n\n        vc = self.presenter.present_custom_view_controller(\n            message=f\"{title}\\n\\n{message}\",\n            animated=True,\n            callback=on_dismiss\n        )\n        return vc\n\n    def show_confirmation(\n        self,\n        title: str,\n        message: str,\n        on_confirm: callable = None,\n        on_cancel: callable = None\n    ):\n        \"\"\"Show a confirmation dialog (simplified example).\"\"\"\n        # In a real implementation, you'd create a custom VC with two buttons\n        def on_dismiss():\n            print(f\"Confirmation dialog dismissed: {title}\")\n            if on_confirm:\n                on_confirm()\n\n        vc = self.presenter.present_custom_view_controller(\n            message=f\"{title}\\n\\n{message}\\n\\nTap Close to confirm\",\n            animated=True,\n            callback=on_dismiss\n        )\n        return vc\n\n# Usage\nalert = AlertDialog()\n\n# Simple message\nalert.show_message(\n    title=\"Success\",\n    message=\"Your operation completed successfully!\",\n    callback=lambda: print(\"User acknowledged success\")\n)\n\n# Confirmation\ntime.sleep(3)\nalert.show_confirmation(\n    title=\"Delete Item\",\n    message=\"Are you sure you want to delete this item?\",\n    on_confirm=lambda: print(\"User confirmed deletion\"),\n    on_cancel=lambda: print(\"User cancelled\")\n)\n</code></pre>"},{"location":"wrapper_examples/uikit_viewcontroller/#advanced-usage-custom-form-view-controller","title":"Advanced Usage: Custom Form View Controller","text":"<pre><code>import UIKit\nimport PythonSwiftLink\n\n@PyClass\nclass FormViewController: UIViewController {\n    private var nameTextField: UITextField!\n    private var emailTextField: UITextField!\n    private var submitButton: UIButton!\n\n    private var submitCallback: PyPointer?\n\n    @PyInit\n    convenience init() {\n        self.init(nibName: nil, bundle: nil)\n    }\n\n    @PyMethod\n    func set_submit_callback(_ callback: PyPointer) {\n        submitCallback = callback\n    }\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n\n        view.backgroundColor = .systemBackground\n\n        // Title label\n        let titleLabel = UILabel()\n        titleLabel.text = \"User Information\"\n        titleLabel.font = .systemFont(ofSize: 28, weight: .bold)\n        titleLabel.textAlignment = .center\n        titleLabel.translatesAutoresizingMaskIntoConstraints = false\n        view.addSubview(titleLabel)\n\n        // Name field\n        nameTextField = UITextField()\n        nameTextField.placeholder = \"Name\"\n        nameTextField.borderStyle = .roundedRect\n        nameTextField.translatesAutoresizingMaskIntoConstraints = false\n        view.addSubview(nameTextField)\n\n        // Email field\n        emailTextField = UITextField()\n        emailTextField.placeholder = \"Email\"\n        emailTextField.keyboardType = .emailAddress\n        emailTextField.borderStyle = .roundedRect\n        emailTextField.translatesAutoresizingMaskIntoConstraints = false\n        view.addSubview(emailTextField)\n\n        // Submit button\n        submitButton = UIButton(type: .system)\n        submitButton.setTitle(\"Submit\", for: .normal)\n        submitButton.titleLabel?.font = .systemFont(ofSize: 18, weight: .semibold)\n        submitButton.backgroundColor = .systemBlue\n        submitButton.setTitleColor(.white, for: .normal)\n        submitButton.layer.cornerRadius = 8\n        submitButton.addTarget(self, action: #selector(submitTapped), for: .touchUpInside)\n        submitButton.translatesAutoresizingMaskIntoConstraints = false\n        view.addSubview(submitButton)\n\n        // Layout\n        NSLayoutConstraint.activate([\n            titleLabel.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor, constant: 40),\n            titleLabel.centerXAnchor.constraint(equalTo: view.centerXAnchor),\n\n            nameTextField.topAnchor.constraint(equalTo: titleLabel.bottomAnchor, constant: 40),\n            nameTextField.leadingAnchor.constraint(equalTo: view.leadingAnchor, constant: 20),\n            nameTextField.trailingAnchor.constraint(equalTo: view.trailingAnchor, constant: -20),\n            nameTextField.heightAnchor.constraint(equalToConstant: 44),\n\n            emailTextField.topAnchor.constraint(equalTo: nameTextField.bottomAnchor, constant: 20),\n            emailTextField.leadingAnchor.constraint(equalTo: view.leadingAnchor, constant: 20),\n            emailTextField.trailingAnchor.constraint(equalTo: view.trailingAnchor, constant: -20),\n            emailTextField.heightAnchor.constraint(equalToConstant: 44),\n\n            submitButton.topAnchor.constraint(equalTo: emailTextField.bottomAnchor, constant: 40),\n            submitButton.leadingAnchor.constraint(equalTo: view.leadingAnchor, constant: 20),\n            submitButton.trailingAnchor.constraint(equalTo: view.trailingAnchor, constant: -20),\n            submitButton.heightAnchor.constraint(equalToConstant: 50)\n        ])\n    }\n\n    @objc private func submitTapped() {\n        guard let name = nameTextField.text, !name.isEmpty,\n              let email = emailTextField.text, !email.isEmpty else {\n            // Could show an alert here\n            return\n        }\n\n        dismiss(animated: true) { [weak self] in\n            guard let self = self, let callback = self.submitCallback else { return }\n            callback.call(name, email)\n        }\n    }\n}\n</code></pre> <pre><code># Python interface for FormViewController\nclass FormViewController:\n    def __init__(self) -&gt; None: ...\n    def set_submit_callback(self, callback: Callable[[str, str], None]) -&gt; None: ...\n\n# Usage\ndef handle_form_submission(name: str, email: str):\n    print(f\"Form submitted!\")\n    print(f\"Name: {name}\")\n    print(f\"Email: {email}\")\n    # Process the data...\n\npresenter = ViewControllerPresenter()\nform_vc = FormViewController()\nform_vc.set_submit_callback(handle_form_submission)\npresenter.present_view_controller(form_vc, animated=True)\n</code></pre> <p>Common UIKit Patterns</p> <p>Auto Layout: Always set <code>translatesAutoresizingMaskIntoConstraints = false</code> when using constraints</p> <p>Safe Area: Use <code>view.safeAreaLayoutGuide</code> for top/bottom anchors to avoid notches</p> <p>Button Actions: Use <code>@objc</code> methods for target-action pattern</p> <p>Keyboard: Remember to handle keyboard show/hide in forms</p> <p>Memory Management</p> <p>Use <code>[weak self]</code> in closures to avoid retain cycles:</p> <pre><code>dismiss(animated: true) { [weak self] in\n    guard let self = self else { return }\n    // Use self safely here\n}\n</code></pre> <p>This is especially important with callbacks that capture view controllers.</p> <p>Presentation Styles</p> <p>UIKit offers different presentation styles:</p> <pre><code>// Full screen (default on iOS 13+)\nviewController.modalPresentationStyle = .fullScreen\n\n// Sheet (card style)\nviewController.modalPresentationStyle = .pageSheet\n\n// Form sheet (centered)\nviewController.modalPresentationStyle = .formSheet\n\n// Automatic (system chooses)\nviewController.modalPresentationStyle = .automatic\n</code></pre> <p>You can expose these as methods in your wrapper.</p>"},{"location":"wrapper_examples/uikit_viewcontroller/#use-cases","title":"Use Cases","text":"<p>User Onboarding <pre><code>class OnboardingManager:\n    def __init__(self):\n        self.presenter = ViewControllerPresenter()\n        self.current_page = 0\n        self.pages = [\n            \"Welcome to the App!\",\n            \"Here's how to get started...\",\n            \"You're all set!\"\n        ]\n\n    def show_onboarding(self):\n        def on_page_complete():\n            self.current_page += 1\n            if self.current_page &lt; len(self.pages):\n                self.show_current_page()\n            else:\n                print(\"Onboarding complete!\")\n\n        self.show_current_page()\n\n    def show_current_page(self):\n        message = self.pages[self.current_page]\n        self.presenter.present_custom_view_controller(\n            message=message,\n            callback=lambda: self.on_page_complete()\n        )\n</code></pre></p> <p>Settings/Preferences <pre><code>class SettingsScreen:\n    def __init__(self):\n        self.presenter = ViewControllerPresenter()\n\n    def show(self, on_save=None):\n        def handle_save(settings_dict):\n            print(f\"Settings saved: {settings_dict}\")\n            if on_save:\n                on_save(settings_dict)\n\n        # Create custom settings VC with form fields\n        settings_vc = CustomViewController()\n        settings_vc.set_message(\"App Settings\")\n        settings_vc.set_dismiss_callback(handle_save)\n        self.presenter.present_view_controller(settings_vc)\n</code></pre></p> <p>Error/Success Messages <pre><code>class MessagePresenter:\n    def __init__(self):\n        self.presenter = ViewControllerPresenter()\n\n    def show_error(self, error: Exception):\n        self.presenter.present_custom_view_controller(\n            message=f\"Error: {str(error)}\",\n            callback=lambda: print(\"Error acknowledged\")\n        )\n\n    def show_success(self, message: str):\n        self.presenter.present_custom_view_controller(\n            message=f\"\u2713 {message}\",\n            callback=lambda: print(\"Success acknowledged\")\n        )\n\n# Usage\nmessenger = MessagePresenter()\ntry:\n    # Some operation...\n    messenger.show_success(\"Operation completed!\")\nexcept Exception as e:\n    messenger.show_error(e)\n</code></pre></p> <p>SwiftUI Alternative</p> <p>While this example uses UIKit (the traditional iOS UI framework), modern iOS apps often use SwiftUI. PySwiftKit can wrap SwiftUI views as well, but the pattern is slightly different. UIKit is still widely used and important for:</p> <ul> <li>Legacy app support</li> <li>Complex custom UI requirements</li> <li>Integration with existing UIKit codebases</li> <li>Features not yet available in SwiftUI</li> </ul>"}]}