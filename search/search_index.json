{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Py-Swift Wiki","text":""},{"location":"setup/","title":"Setup","text":"<p>Add Brew Tap</p> <pre><code>brew tap PythonSwiftLink/tools\n</code></pre>"},{"location":"setup/#psproject","title":"PSProject","text":"<p>Install PSProject</p> <pre><code>brew install psproject\n</code></pre> <p>Upgrade PSProject</p> <pre><code>brew update\nbrew upgrade --formula psproject\n</code></pre>"},{"location":"project/kivy/create/","title":"Kivy","text":"<p>!!! info First create uv project which psproject will use the pyproject.toml as project info     <pre><code>psproject init kivy_app\n</code></pre></p> <p>!!! info You should now have a kivy_app/pyproject.toml looking like this:     <pre><code>[project]\nname = \"kivy-app\" # have no effect on the xcode app name\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nreadme = \"README.md\"\nauthors = [\n    { name = \"Name\", email = \"name@email.com\" }\n]\nrequires-python = \"&gt;=3.11.11\"\ndependencies = []\n\n[build-system]\nrequires = [\"uv_build&gt;=0.8.4,&lt;0.9.0\"]\nbuild-backend = \"uv_build\"\n\n\n[dependency-groups]\niphoneos = []\n\n[pyswift.project]\nbackends = []\nbundle_id = \"org.pyswift.kivy_app\"\nfolder_name = \"kivy_app\"\nname = \"kivy_app\"\npip_install_app = false\nplatforms = [ \"iphoneos\" ]\nswift_sources = []\n\n[pyswift.project.dependencies]\npips = []\n\n[pyswift.project.plist]\n\n[pyswift.swift-packages]\n</code></pre></p> <p>!!! info Now change the following properties to run a kivy based app:     <pre><code>[project]\ndependencies = [\n    \"kivy\",\n    # add other pip requirements here\n]\n\n[pyswift.project]\nbackends = [\n    \"kivylauncher\"\n]\nbundle_id = \"org.pyswift.my_kivy_app\" # example\nfolder_name = \"MyKivyApp-apple\" # example\nname = \"MyKivyApp\" # example\n</code></pre></p> <p>!!! info To create the xcode project, type the following command     <pre><code>psproject create --uv kivy_app\n</code></pre></p>"},{"location":"wrapper_docs/types/","title":"Types","text":"<p>TypeCasting</p> <p>PythonSwiftLink / Swiftonize will automatic convert between the following python/swift types:</p> Python cast from/to Swift int Int int Int32 int Int16 int Int8 int UInt int UInt32 int UInt16 int UInt8 float Double float Float float Float16 object PyPointer str String bytes Data bytes [UInt8] bytearray Data bytearray [UInt8] memoryview Data memoryview [UInt8] list[int] [Int] list[int] [Int32] list[int] [Int16] list[int] [Int8] list[int] [UInt] list[int] [UInt32] list[int] [UInt16] list[int] [UInt8] list[float] [Double] list[float] [Float] list[float] [Float16] list[object] [PyPointer] list[str] [String] list[bytes] [Data] list[bytes] [[UInt8]] list[bytearray] [Data] list[bytearray] [[UInt8]] list[memoryview] [Data] list[memoryview] [[UInt8]]"},{"location":"wrapper_examples/hello_world/","title":"Hello world","text":""},{"location":"wrapper_examples/hello_world/#getting-started","title":"Getting started","text":""},{"location":"wrapper_examples/hello_world/#helloworld-part-1","title":"HelloWorld Part 1","text":"<p>Call Swift from Python:</p> HelloWorld.swift<pre><code>public class HelloWorld {\n\n    init() {\n\n    }\n\n    func send_string(text: String) {\n        print(text)\n    }\n\n}\n</code></pre> HelloWorld.swift<pre><code>import PySwiftKit\nimport PySerializing\nimport PySwiftObject\nimport PySwiftWrapper\n\n\n@PyClass\nclass HelloWorld {\n\n    @PyInit\n    init() {\n\n    }\n\n    @PyMethod\n    func send_string(text: String) {\n        print(text)\n    }\n\n}\n\n@PyModule\nstruct hello_world: PyModuleProtocol {\n    static var py_classes: [any (PyClassProtocol &amp; AnyObject).Type] = [\n        HelloWorld.self\n    ]\n}\n</code></pre> <p>==</p> hello_world.py<pre><code>class HelloWorld:\n\n    def __init__(self)...\n\n    def send_string(self, text: str): ...\n</code></pre>"},{"location":"wrapper_examples/hello_world/#helloworld-part-2","title":"HelloWorld Part 2","text":"<p>Make callback from Swift to Python:</p> HelloWorld.swift<pre><code>@PyClass\nclass HelloWorld {\n\n    var _callback: PyPointer\n\n    @PyInit\n    init(callback: PyPointer) {\n        _callback = callback\n    }\n\n    @PyMethod\n    func send_string(text: String) {\n        callback(\n            text + \" World\"\n        )\n    }\n\n    /* \n    {} is not needed, PyCall will automatic fill out the function body\n    by default PyCall will target a variable that should be a underscored name\n    of the function, this case _callback.\n    but you can use the name: \"another_name\" in the argument input on @PyCall\n    to target another name.\n    */\n    @PyCall \n    func callback(text: String)\n\n}\n</code></pre> main.py<pre><code>from hello_world import HelloWorld\n\ndef callback(text: str):\n    print(text)\n\nhw = HelloWorld(callback)\nhw.send_string(\"Hello\")\n\nhw = HelloWorld(lambda text: print(text))\nhw.send_string(\"Hello\")\n</code></pre>"},{"location":"wrapper_examples/hello_world/#helloworld-part-3","title":"HelloWorld Part 3","text":"<p>Make callback from Swift to Python by converting a Py-Function/Method into a Swift Function Closure:</p> <ul> <li>Pros<ul> <li>No need for storing a variable to call, that happens inside the closure.</li> </ul> </li> <li>Cons</li> <li>By default the swift closure can't keep a strong ref to the temporary     object of passed pyfunction. so its important that one of the following conditions are meet         1. The callback should happen within the life cycle of the function that was passed to it.         2. If the callback is ment to be called later on, then its importamt the pyfunction should be stored in python as a strongref that will keep the temporary object to the pyfunction alive, while callback is happening.</li> </ul> HelloWorld.swift<pre><code>@PyClass\nclass HelloWorld2 {\n\n    @PyInit\n    init() {\n\n    }\n\n    @PyMethod\n    func send_string(text: String, callback: @escaping (String)-&gt;Void) {\n        // this matches condition 1\n        callback(\n            text + \" World\"\n        )\n    }\n\n}\n</code></pre> main.py<pre><code>from hello_world import HelloWorld\n\ndef callback(text: str):\n    print(text)\n\nhw = HelloWorld()\n\nhw.send_string(\"Hello\", callback)\n\nhw.send_string(\"Hello\", lambda text: print(text))\n</code></pre>"}]}